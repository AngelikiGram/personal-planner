<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
        <title>Grand Adventure üêæ</title>
        <link rel="manifest" href="/ios-app/www/manifest.json">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="apple-touch-icon" href="/ios-app/www/icons/icon-192.png">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <!-- Firebase SDKs (Compat version for easier HTML usage) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --ios-pink: #ff2d55;
            --grass: #9de64e;
            --path: #e3c18d;
            --path-depth: #c4a484;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Outfit', sans-serif;
            background-color: #f2f2f7;
            display: flex; flex-direction: column;
            height: 100vh; overflow: hidden;
        }

        /* --- iOS Header --- */
        .header {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            padding: 12px 20px;
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 0.5px solid #d1d1d6;
            z-index: 1000;
        }

        .rank-pill {
            background: var(--ios-pink); color: white;
            padding: 6px 14px; border-radius: 20px;
            font-size: 11px; font-weight: 800;
            box-shadow: 0 4px 10px rgba(255, 45, 85, 0.3);
        }

        .coin-display { font-weight: 900; color: #ff9500; font-size: 18px; }

        /* --- 3D HILL VIEWPORT --- */
        .viewport {
            flex: 2.2;
            overflow: hidden;
            position: relative;
            background: transparent;
        }
        .viewport canvas { display: block; }
        .loc-label-3d {
            position: absolute;
            transform: translate(-50%, -100%);
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            z-index: 5;
            transition: transform 0.15s;
        }
        .loc-label-3d:active { transform: translate(-50%, -100%) scale(0.9); }
        .loc-label-3d.loc-active .loc-tag-3d {
            background-color: #ffd60a;
            transform: scale(1.3);
            border-width: 2px;
            box-shadow: 0 4px 12px rgba(255, 214, 10, 0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .loc-icon-3d {
            font-size: 22px;
            display: block;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
        }
        .loc-tag-3d {
            background: rgba(255,255,255,0.92);
            padding: 1px 6px;
            border-radius: 6px;
            font-size: 8px;
            font-weight: bold;
            border: 1.5px solid #333;
            white-space: nowrap;
            display: inline-block;
            backdrop-filter: blur(4px);
        }
        /* HUD LIST & MENU */
        .loc-menu-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 10px 16px;
            border-radius: 20px;
            font-weight: 800;
            color: #333;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.1s;
        }
        .loc-menu-btn:active { transform: scale(0.95); }
        
        .loc-list-hud {
            position: absolute;
            top: 68px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 16px;
            width: 210px;
            pointer-events: auto;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 4px;
            z-index: 19;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            transform-origin: top left;
            animation: menu-pop 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-height: 50vh;
            overflow-y: auto;
        }
        .loc-list-hud.show { display: flex; }
        
        @keyframes menu-pop {
            from { opacity: 0; transform: scale(0.8) translateY(-10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .loc-list-title {
            font-size: 10px;
            font-weight: 900;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 4px 8px;
        }
        .loc-list-item {
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            padding: 10px 12px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #333;
            transition: background 0.2s;
            background: white;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .loc-list-item:hover { background: #f2f2f7; }
        .loc-list-item.locked {
            color: #999;
            background: #f9f9f9;
        }
        .loc-list-item.locked span { filter: grayscale(1); opacity: 0.6; }
        .loc-list-item .lock-icon { font-size: 10px; margin-left: auto; color: #ccc; }
        .loc-list-item.locked .lock-icon { content: 'üîí'; }
        .loc-tag-3d.unlocked { border-color: var(--ios-pink); background: rgba(255,230,238,0.95); }
        .loc-tag-3d.locked { opacity: 0.5; }

        /* Mobile / iOS safe-area adjustments */
        :root { --vh: 1vh; --header-h: 64px; }

        @media (max-width: 700px) {
            body { padding-top: env(safe-area-inset-top); padding-bottom: env(safe-area-inset-bottom); }
            .header { position: fixed; top: env(safe-area-inset-top, 20px); left: 0; right: 0; z-index: 2000; padding-top: calc(12px + env(safe-area-inset-top, 20px)); padding-bottom: 12px; pointer-events: auto; }
            .main-split { margin-top: calc(var(--header-h, 64px) + env(safe-area-inset-top, 20px) + 6px); }
            /* Ensure the button and HUD live within the `.viewport` screen area */
            .viewport .loc-menu-btn { top: 10px; left: 10px; font-size: 14px; padding: 8px 12px; }
            .loc-list-hud { top: calc(var(--header-h, 64px) + env(safe-area-inset-top) + 8px); left: 12px; width: calc(100% - 24px); max-height: 48vh; overflow-y: auto; font-size: 13px; }
            .loc-list-item { font-size: 12px; padding: 8px 10px; }
            /* Use a JS-driven --vh to avoid browser chrome issues on mobile */
            .viewport { height: calc(var(--vh, 1vh) * 100 - var(--header-h, 64px)); }
        }

        /* Location Detail Modal */
        .loc-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.45);
            z-index: 3000;
            display: none; align-items: flex-end; justify-content: center;
        }
        .loc-overlay.show { display: flex; }
        .loc-modal {
            background: white; border-radius: 22px 22px 0 0; padding: 24px;
            width: 100%; max-width: 420px; max-height: 65vh;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.2);
            animation: slideUp 0.3s ease-out;
        }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        .loc-header { display: flex; align-items: center; gap: 12px; margin-bottom: 14px; }
        .loc-header .loc-h-icon { font-size: 42px; }
        .loc-header .loc-h-info h3 { margin: 0; font-weight: 900; font-size: 18px; }
        .loc-header .loc-h-info .loc-h-status { font-size: 11px; font-weight: 700; }
        .loc-h-status.unlocked { color: #34c759; }
        .loc-h-status.locked { color: #ff3b30; }
        .loc-activities { overflow-y: auto; max-height: 35vh; }
        .loc-act-card {
            background: #f2f2f7; border-radius: 14px; padding: 12px 14px;
            margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;
        }
        .loc-act-card .la-info { font-weight: 700; font-size: 14px; }
        .loc-act-card .la-desc { font-size: 11px; color: #8e8e93; }
        .loc-act-card .la-reward { color: #ff9500; font-weight: 800; font-size: 12px; }
        .loc-act-btn { background: var(--ios-pink); color: white; border: none; padding: 8px 16px; border-radius: 10px; font-weight: 700; font-size: 12px; cursor: pointer; }
        .loc-act-btn:disabled { background: #d1d1d6; }
        .loc-close {
            display: block; width: 100%; margin-top: 12px; background: none; border: none;
            color: var(--ios-pink); font-weight: 800; font-size: 15px; cursor: pointer; text-align: center;
        }

        /* Profile overlay */
        .profile-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .profile-overlay.show { display: flex; }
        .profile-modal {
            background: white; border-radius: 22px; padding: 24px;
            width: 300px; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
        }
        .profile-avatar {
            width: 80px; height: 80px; border-radius: 50%;
            background: var(--ios-pink); display: flex; align-items: center; justify-content: center;
            font-size: 40px; margin: 0 auto 12px;
            box-shadow: 0 4px 15px rgba(255,45,85,0.3);
        }
        .profile-name { font-weight: 900; font-size: 20px; margin-bottom: 4px; }
        .profile-bio { font-size: 13px; color: #8e8e93; margin-bottom: 16px; }
        .profile-stats { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
        .pstat {
            flex: 1; background: #f2f2f7; border-radius: 14px; padding: 10px 6px;
            text-align: center;
        }
        .pstat .pstat-val { font-weight: 900; font-size: 18px; color: var(--ios-pink); }
        .pstat .pstat-lbl { font-size: 10px; color: #8e8e93; font-weight: 600; }
        .profile-section { text-align: left; margin-bottom: 14px; }
        .profile-section label { font-weight: 700; font-size: 12px; color: #8e8e93; display: block; margin-bottom: 4px; }
        .profile-section input, .profile-section textarea {
            width: 100%; box-sizing: border-box;
            padding: 10px; border-radius: 12px; border: 1px solid #ddd;
            font-size: 14px; font-family: 'Outfit', sans-serif;
        }
        .profile-section textarea { resize: none; height: 60px; }
        .avatar-picker { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; margin-bottom: 14px; }
        .avatar-opt {
            width: 42px; height: 42px; border-radius: 50%; border: 2px solid #ddd;
            display: flex; align-items: center; justify-content: center;
            font-size: 22px; cursor: pointer; background: white;
        }
        .avatar-opt.selected { border-color: var(--ios-pink); background: #fff0f3; }
        .profile-save { background: var(--ios-pink); color: white; border: none; padding: 12px; border-radius: 14px; font-weight: 800; font-size: 14px; cursor: pointer; width: 100%; margin-top: 6px; }
        .profile-close { background: none; border: none; color: var(--ios-pink); font-weight: 800; font-size: 15px; cursor: pointer; margin-top: 10px; }

        /* --- CONTENT & SHOP --- */
        .content {
            flex: 1; background: #fff;
            border-top: 1px solid #d1d1d6;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        .tabs { display: flex; background: #f9f9f9; border-bottom: 0.5px solid #d1d1d6; }
        .tab { flex: 1; padding: 12px 4px; text-align: center; font-weight: 700; color: #8e8e93; font-size: 13px; cursor: pointer; }
        .tab.active { color: var(--ios-pink); border-bottom: 3px solid var(--ios-pink); }

        .list-container { flex: 1; overflow-y: auto; padding: 15px; }
        .card {
            background: #f2f2f7; border-radius: 18px; padding: 16px; margin-bottom: 12px;
            display: flex; justify-content: space-between; align-items: center;
        }

        .btn-ios {
            background: var(--ios-pink); color: white; border: none;
            padding: 10px 20px; border-radius: 12px; font-weight: 700;
        }
        .btn-ios:disabled { background: #d1d1d6; }

        /* Rank Modal */
        .rank-pill { cursor: pointer; }
        .rank-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .rank-overlay.show { display: flex; }
        .rank-modal {
            background: white; border-radius: 20px; padding: 24px;
            width: 280px; max-height: 70vh; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex; flex-direction: column;
        }
        .rank-modal h3 { margin: 0 0 16px; font-weight: 900; font-size: 18px; }
        #rank-list { overflow-y: auto; flex: 1; }
        .rank-row {
            display: flex; align-items: center; gap: 12px;
            padding: 10px 14px; border-radius: 14px; margin-bottom: 8px;
            background: #f2f2f7; font-weight: 700; font-size: 14px;
        }
        .rank-row.current { background: var(--ios-pink); color: white; }
        .rank-row .rank-icon { font-size: 22px; }
        .rank-row .rank-threshold { font-size: 11px; font-weight: 400; margin-left: auto; opacity: 0.7; }
        .rank-close {
            margin-top: 14px; background: none; border: none;
            color: var(--ios-pink); font-weight: 800; font-size: 16px; cursor: pointer;
        }

        /* Voucher Modal */
        .voucher-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .voucher-overlay.show { display: flex; }
        .voucher-modal {
            background: white; border-radius: 20px; padding: 24px;
            width: 300px; max-height: 70vh; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex; flex-direction: column;
        }
        .voucher-modal h3 { margin: 0 0 16px; font-weight: 900; font-size: 18px; }
        .voucher-list { overflow-y: auto; flex: 1; }
        .voucher-card {
            background: linear-gradient(135deg, #fff0f3, #ffe0e6);
            border: 2px dashed var(--ios-pink);
            border-radius: 14px; padding: 14px; margin-bottom: 10px;
            text-align: left; position: relative;
        }
        .voucher-card .v-title { font-weight: 800; font-size: 15px; }
        .voucher-card .v-date { font-size: 11px; color: #8e8e93; margin-top: 4px; }
        .voucher-card .v-stamp {
            position: absolute; top: 10px; right: 12px;
            font-size: 24px;
        }
        .voucher-card.redeemed {
            background: linear-gradient(135deg, #f0f0f0, #e8e8e8);
            border-color: #ccc;
            opacity: 0.65;
        }
        .voucher-card.redeemed .v-title { text-decoration: line-through; }
        .voucher-card .v-status {
            display: inline-block; margin-top: 8px;
            font-size: 11px; font-weight: 800; padding: 4px 10px;
            border-radius: 8px;
        }
        .voucher-card .v-status.open {
            background: var(--ios-pink); color: white; cursor: pointer;
        }
        .voucher-card .v-status.used {
            background: #d1d1d6; color: #666;
        }
        .voucher-empty { color: #8e8e93; padding: 30px 0; font-size: 14px; }
        .voucher-close {
            margin-top: 14px; background: none; border: none;
            color: var(--ios-pink); font-weight: 800; font-size: 16px; cursor: pointer;
        }

        /* Add Quest Modal */
        .addq-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 3000;
            display: none; align-items: center; justify-content: center;
        }
        .addq-overlay.show { display: flex; }
        .addq-modal {
            background: white; border-radius: 20px; padding: 24px;
            width: 290px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .addq-modal h3 { margin: 0 0 16px; font-weight: 900; font-size: 18px; }
        .addq-modal input {
            width: 100%; box-sizing: border-box;
            padding: 12px; border-radius: 12px; border: 1px solid #ddd;
            font-size: 15px; font-family: 'Outfit', sans-serif;
            margin-bottom: 10px;
        }
        .addq-modal input[type=number] { -moz-appearance: textfield; }
        .addq-btns { display: flex; gap: 10px; margin-top: 6px; }
        .addq-btns button { flex: 1; padding: 12px; border-radius: 12px; font-weight: 700; font-size: 14px; border: none; cursor: pointer; }
        .addq-btns .addq-save { background: var(--ios-pink); color: white; }
        .addq-btns .addq-cancel { background: #f2f2f7; color: #333; }

        .add-quest-btn {
            width: 100%; padding: 14px; border: 2px dashed #d1d1d6;
            border-radius: 18px; background: none;
            font-weight: 700; font-size: 14px; color: #8e8e93;
            cursor: pointer; margin-bottom: 12px;
        }
        .add-quest-btn:active { background: #f2f2f7; }

        /* Login Screen */
        #login {
            position: fixed; inset: 0; background: #fff; z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .ios-input { padding: 15px; border-radius: 15px; border: 1px solid #ddd; width: 250px; text-align: center; font-size: 18px; margin-bottom: 20px; }

        /* Black Cat */
        @keyframes cat-appear {
            0% { transform: scale(0) rotate(-30deg); opacity: 0; }
            50% { transform: scale(1.15) rotate(5deg); opacity: 1; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        @keyframes cat-eyes {
            0%, 90%, 100% { opacity: 1; }
            95% { opacity: 0; }
        }
        @keyframes cat-shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px) rotate(-2deg); }
            40% { transform: translateX(8px) rotate(2deg); }
            60% { transform: translateX(-6px) rotate(-1deg); }
            80% { transform: translateX(6px) rotate(1deg); }
        }
        @keyframes cat-vanish {
            0% { transform: scale(1) rotate(0); opacity: 1; }
            100% { transform: scale(0) rotate(40deg); opacity: 0; }
        }
        @keyframes penalty-flash {
            0%, 100% { background: rgba(0,0,0,0.5); }
            50% { background: rgba(255,0,0,0.35); }
        }
        .cat-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 4000;
            display: none; align-items: center; justify-content: center;
            flex-direction: column;
        }
        .cat-overlay.show { display: flex; }
        .cat-overlay.penalty { animation: penalty-flash 0.3s 3; }
        .cat-modal {
            text-align: center;
            animation: cat-appear 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        .cat-modal.leaving {
            animation: cat-vanish 0.4s ease-in forwards;
        }
        .cat-emoji {
            font-size: 100px;
            display: block;
            filter: drop-shadow(0 10px 25px rgba(0,0,0,0.5));
            animation: cat-eyes 4s infinite;
        }
        .cat-bubble {
            background: white; border-radius: 20px; padding: 20px 24px;
            margin-top: 16px; max-width: 280px;
            box-shadow: 0 15px 50px rgba(0,0,0,0.4);
            position: relative;
        }
        .cat-bubble::before {
            content: ''; position: absolute; top: -10px; left: 50%; transform: translateX(-50%);
            border-left: 10px solid transparent; border-right: 10px solid transparent;
            border-bottom: 12px solid white;
        }
        .cat-bubble .cat-q {
            font-weight: 800; font-size: 16px; color: #1a1a1a;
            margin-bottom: 16px; line-height: 1.4;
        }
        .cat-btns { display: flex; gap: 10px; }
        .cat-btns button {
            flex: 1; padding: 14px; border: none; border-radius: 14px;
            font-weight: 800; font-size: 15px; cursor: pointer;
        }
        .cat-btn-yes { background: #34c759; color: white; }
        .cat-btn-no { background: #ff3b30; color: white; }
        .cat-btn-yes:active { transform: scale(0.95); }
        .cat-btn-no:active { transform: scale(0.95); }
        .cat-penalty-txt {
            color: #ff3b30; font-weight: 900; font-size: 22px;
            margin-top: 14px;
            animation: cat-shake 0.5s;
        }
        .cat-safe-txt {
            color: #34c759; font-weight: 900; font-size: 18px;
            margin-top: 14px;
        }

        /* Reset Modal */
        .reset-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 5000;
            display: none; align-items: center; justify-content: center;
        }
        .reset-overlay.show { display: flex; }
        .reset-modal {
            background: white; border-radius: 20px; padding: 24px;
            width: 280px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .reset-modal h3 { margin: 0 0 8px; font-weight: 900; font-size: 18px; }
        .reset-modal p { margin: 0 0 18px; font-size: 13px; color: #8e8e93; }
        .reset-btns { display: flex; gap: 10px; }
        .reset-btns button { flex: 1; padding: 13px; border: none; border-radius: 14px; font-weight: 800; font-size: 14px; cursor: pointer; }
        .reset-btn-cancel { background: #f2f2f7; color: #333; }
        .reset-btn-confirm { background: #ff3b30; color: white; }
        /* Responsive & Main Layout Overrides */
        .main-split {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
        }
        .viewport {
            flex: 4.5;
            position: relative;
            overflow: hidden;
            background: transparent;
        }
        .content {
            flex: 1.5;
            background: #fff;
            border-left: 1px solid #d1d1d6;
            border-top: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Mobile Optimization */
        @media (max-width: 800px) {
            .main-split {
                flex-direction: column;
            }
            .viewport {
                flex: 2; /* Increased flex ratio for mobile as requested */
                min-height: 60vh; /* Ensure 3D view is larger on phone */
            }
            .content {
                flex: 1.5; /* Give more space to content on mobile */
                border-left: none;
                border-top: 1px solid #d1d1d6;
            }
            /* Adjust modals for smaller screens */
            .modal-content, .cat-bubble, .reset-modal, .ios-input, .btn-ios, .voucher-modal, .addq-modal, .rank-modal {
                width: 90% !important;
                max-width: 320px !important;
            }
            .ios-input {
                font-size: 16px; /* prevent zoom on focus on iOS */
            }
        }
    </style>
    <script>
        // Ensure mobile viewport units work reliably and measure header height
        (function(){
            function setVh() {
                document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
                const hdr = document.querySelector('.header');
                const h = hdr ? Math.round(hdr.getBoundingClientRect().height) : 64;
                document.documentElement.style.setProperty('--header-h', h + 'px');
            }
            window.addEventListener('resize', setVh);
            window.addEventListener('orientationchange', setVh);
            window.addEventListener('load', setVh);
            // run now
            setVh();
        })();
    </script>
</head>
<body>

    <div id="login">
        <div style="font-size: 80px; margin-bottom: 20px;">üêï</div>
        <h2 style="font-weight: 900;">My Quest</h2>
        <input type="password" id="pass" class="ios-input" placeholder="World's Best Boarder Collie" oninput="this.value = this.value.toLowerCase()"> 
        <!-- "Password or Profile Name"> -->
        <button class="btn-ios" style="width: 250px; padding: 15px;" onclick="enterApp()">Unlock Adventure</button>
        <p style="margin-top: 20px; color: #8e8e93; font-size: 13px; max-width: 260px; text-align: center; line-height: 1.4;">
            ‚ú® <b>Tip:</b> Enter <b style="color:#000">louis</b> for offline mode.<br>
            Enter a <b style="color:var(--ios-pink)">Unique Name</b> (e.g. AngieWorld) to create a Cloud Save!
        </p>
    </div>

    <div class="header">
        <div class="rank-pill" id="rank-name" onclick="showRanks()">KOALA</div>
        <div style="display:flex; align-items:center; gap:12px;">
            <div class="coin-display" id="coin-txt">üí∞ 0000</div>
            <div style="font-size:22px; cursor:pointer; position:relative;" onclick="showVouchers()">üéüÔ∏è<span id="voucher-badge" style="position:absolute;top:-6px;right:-10px;background:var(--ios-pink);color:white;font-size:10px;font-weight:800;min-width:16px;height:16px;line-height:16px;border-radius:10px;text-align:center;padding:0 4px;display:none;"></span></div>
            <div id="header-avatar" style="width:30px;height:30px;border-radius:50%;background:var(--ios-pink);display:flex;align-items:center;justify-content:center;font-size:16px;cursor:pointer;box-shadow:0 2px 8px rgba(255,45,85,0.3);" onclick="showProfile()">üêï</div>
            <div style="font-size:18px; cursor:pointer; opacity:0.5;" onclick="showReset()">‚öôÔ∏è</div>
        </div>
    </div>

    <div class="main-split">
        <div class="viewport" id="viewport"></div>
        <div class="content">
            <div class="tabs">
                <div class="tab active" id="tab-q" onclick="setTab('q')">Quests</div>
                <div class="tab" id="tab-s" onclick="setTab('s')">Shop</div>
            </div>
            <div class="list-container" id="main-list"></div>
        </div>
    </div>

    <div class="loc-overlay" id="loc-overlay" onclick="if(event.target===this)closeLoc()">
        <div class="loc-modal">
            <div class="loc-header">
                <span class="loc-h-icon" id="loc-h-icon"></span>
                <div class="loc-h-info">
                    <h3 id="loc-h-name"></h3>
                    <div class="loc-h-status" id="loc-h-status"></div>
                </div>
            </div>
            <div class="loc-activities" id="loc-activities"></div>
            <button class="loc-close" onclick="closeLoc()">Close</button>
        </div>
    </div>

    <div class="profile-overlay" id="profile-overlay" onclick="if(event.target===this)closeProfile()">
        <div class="profile-modal">
            <div class="profile-avatar" id="pf-avatar-display">üêï</div>
            <div class="profile-name" id="pf-name-display">Adventurer</div>
            <div class="profile-bio" id="pf-bio-display">On a quest for greatness!</div>
            <div class="profile-stats">
                <div class="pstat"><div class="pstat-val" id="pf-coins">0</div><div class="pstat-lbl">COINS</div></div>
                <div class="pstat"><div class="pstat-val" id="pf-total">0</div><div class="pstat-lbl">TOTAL XP</div></div>
                <div class="pstat"><div class="pstat-val" id="pf-vouchers">0</div><div class="pstat-lbl">VOUCHERS</div></div>
            </div>
            <div id="pf-extra-stats"></div>
            <div style="text-align:left;font-weight:800;font-size:13px;margin-bottom:8px;">Choose Avatar</div>
            <div class="avatar-picker" id="avatar-picker"></div>
            <div class="profile-section">
                <label>Display Name</label>
                <input type="text" id="pf-name-input" maxlength="20" placeholder="Your name">
            </div>
            <div class="profile-section">
                <label>Bio</label>
                <textarea id="pf-bio-input" maxlength="80" placeholder="Tell us about yourself..."></textarea>
            </div>
            <button class="profile-save" onclick="saveProfile()">Save Profile</button>
            <button class="profile-close" onclick="closeProfile()">Close</button>
        </div>
    </div>

    <div class="addq-overlay" id="addq-overlay" onclick="if(event.target===this)closeAddQuest()">
        <div class="addq-modal">
            <h3>‚ú® New Quest</h3>
            <input type="text" id="addq-name" placeholder="Quest name" maxlength="40">
            <input type="text" id="addq-desc" placeholder="Description (optional)" maxlength="60">
            <input type="number" id="addq-pts" placeholder="Points" min="5" max="500">
            <div class="addq-btns">
                <button class="addq-cancel" onclick="closeAddQuest()">Cancel</button>
                <button class="addq-save" onclick="saveNewQuest()">Add</button>
            </div>
        </div>
    </div>

    <div class="addq-overlay" id="addr-overlay" onclick="if(event.target===this)closeAddReward()">
        <div class="addq-modal">
            <h3>üéÅ New Reward</h3>
            <input type="text" id="addr-name" placeholder="Reward name" maxlength="40">
            <input type="text" id="addr-desc" placeholder="Description (optional)" maxlength="60">
            <input type="number" id="addr-price" placeholder="Price (coins)" min="10" max="50000">
            <div class="addq-btns">
                <button class="addq-cancel" onclick="closeAddReward()">Cancel</button>
                <button class="addq-save" onclick="saveNewReward()">Add</button>
            </div>
        </div>
    </div>

    <div class="voucher-overlay" id="voucher-overlay" onclick="if(event.target===this)closeVouchers()">
        <div class="voucher-modal">
            <h3>üéüÔ∏è My Vouchers</h3>
            <div class="voucher-list" id="voucher-list"></div>
            <button class="voucher-close" onclick="closeVouchers()">Close</button>
        </div>
    </div>

    <div class="rank-overlay" id="rank-overlay" onclick="if(event.target===this)closeRanks()">
        <div class="rank-modal">
            <h3>üèÜ All Ranks</h3>
            <div id="rank-list"></div>
            <button class="rank-close" onclick="closeRanks()">Close</button>
        </div>
    </div>

    <div class="reset-overlay" id="reset-overlay" onclick="if(event.target===this)closeReset()">
        <div class="reset-modal">
            <h3>‚ö†Ô∏è Reset Everything?</h3>
            <p>This will erase all coins, ranks, vouchers, custom quests & rewards. No going back!</p>
            <div class="reset-btns">
                <button class="reset-btn-cancel" onclick="closeReset()">Cancel</button>
                <button class="reset-btn-confirm" onclick="confirmReset()">Reset All</button>
            </div>
        </div>
    </div>

    <div class="cat-overlay" id="cat-overlay">
        <div class="cat-modal" id="cat-modal">
            <span class="cat-emoji">üêà‚Äç‚¨õ</span>
            <div class="cat-bubble">
                <div class="cat-q" id="cat-question"></div>
                <div class="cat-btns" id="cat-btns">
                    <button class="cat-btn-yes" onclick="catAnswer(true)">Yes ‚úÖ</button>
                    <button class="cat-btn-no" onclick="catAnswer(false)">No üôà</button>
                </div>
                <div id="cat-result"></div>
            </div>
        </div>
    </div>

    <script>
        // --- FIREBASE CONFIGURATION ---
        // 1. Go to console.firebase.google.com
        // 2. Create a project
        // 3. Add a Web App
        // 4. Paste the 'firebaseConfig' object here:
        const firebaseConfig = {
            apiKey: "AIzaSyCMrsI3vi4L4OUveDWsOj1ktgSnKNYdG4o",

            authDomain: "project-planner-21966.firebaseapp.com",

            projectId: "project-planner-21966",

            storageBucket: "project-planner-21966.firebasestorage.app",

            messagingSenderId: "1019453990592",

            appId: "1:1019453990592:web:2c1ad708c2809ed3e06f25",

            measurementId: "G-YQ01HT7F5Z"
        };


        // Initialize Firebase if config is present
        let db, auth, userRef;
        window.isFirebaseReady = false;
        
        if (firebaseConfig.apiKey && firebaseConfig.apiKey !== "PASTE_API_KEY_HERE") {
            try {
                if (!firebase.apps.length) {
                     firebase.initializeApp(firebaseConfig);
                }
                
                db = firebase.firestore();
                auth = firebase.auth();
                
                // Enable Offline Persistence (Makes saves instant & works offline)
                db.enablePersistence({ synchronizeTabs: true })
                  .then(() => console.log("Offline persistence enabled"))
                  .catch((err) => {
                      if (err.code == 'failed-precondition') {
                          console.warn("Persistence failed: Multiple tabs open. (Only one tab can sync)");
                      } else if (err.code == 'unimplemented') {
                          console.warn("Persistence not supported by browser");
                      }
                  });

                window.isFirebaseReady = true;
                console.log("Firebase initialized successfully");
            } catch (e) {
                console.error("Firebase Init Error:", e);
                alert("Firebase Error: " + e.message);
            }
        } else {
            console.log("Firebase not configured - using Local Storage only.");
        }
        
        // --- APP STATE ---
        let coins = parseInt(localStorage.getItem('b_coins')) || 0;
        let total = parseInt(localStorage.getItem('b_total')) || 0;
        let vouchers = JSON.parse(localStorage.getItem('b_vouchers')) || [];
        let customQuests = JSON.parse(localStorage.getItem('b_custom_quests')) || [];
        let customRewards = JSON.parse(localStorage.getItem('b_custom_rewards')) || [];
        // Profile handles its own load in init for Firebase, but default here:
        let profile = JSON.parse(localStorage.getItem('b_profile')) || { name: 'Adventurer', bio: 'On a quest for greatness!', avatar: '\uD83D\uDC15' };
        
        let tab = 'q';
        let catTimer = null;
        let unsubscribe = null; // Firestore listener

        const catQuestions = [
            { q: "Were you punctual at school today?", penalty: 40 },
            { q: "How clean is your kitchen right now? Be honest!", penalty: 35 },
            { q: "How clean is your bathroom? Spotless?", penalty: 35 },
            { q: "How clean is your bedroom? Really?", penalty: 30 },
            { q: "How clean is the living room?", penalty: 30 },
            { q: "Did you do something for the master thesis today?", penalty: 30 },
            { q: "Did you give the doggo his pill?", penalty: 45 },
            { q: "Did you eat a proper meal today?", penalty: 25 },
            { q: "Did you drink enough water today?", penalty: 20 },
            { q: "Did you go outside for fresh air?", penalty: 20 },
            { q: "Were you on time meeting your friends?", penalty: 35 },
            { q: "Did you stretch or exercise today?", penalty: 25 },
            { q: "Did you remember to call your family?", penalty: 30 },
            { q: "Were you on time at doggo school?", penalty: 40 },
            { q: "Did you tidy up after cooking?", penalty: 30 },
            { q: "Did you avoid doom-scrolling today?", penalty: 20 },
            { q: "Did you go to bed on time last night?", penalty: 35 },
            { q: "Did you prepare Louis's food on time?", penalty: 30 }
        ];

        const quests = [
            { t: "Thesis Progress üìù", d: "One more page closer to the finish!", r: 50 },
            { t: "The Great Flat Clean üßπ", d: "Make my castle shine.", r: 100 },
            { t: "Louis Walking Duty üêæ", d: "Good boy needs his steps.", r: 40 },
            { t: "Baking a Treat üßÅ", d: "Sweet rewards for sweet efforts.", r: 60 },
            { t: "Morning Routine ‚òÄÔ∏è", d: "Up, fresh & ready on time!", r: 35 },
            { t: "Punctual at School üéì", d: "On time, every time.", r: 45 },
            { t: "Punctual at Doggo School üê∂", d: "Louis appreciates punctuality.", r: 45 },
            { t: "Punctual with Friends üëØ", d: "Never keep them waiting!", r: 40 }
        ];

        const shop = [
            { t: "Infinite Cuddles üê®", d: "Best used with a blanket.", p: 100 },
            { t: "Pancake Breakfast ü•û", d: "A chef's kiss morning.", p: 250 },
            { t: "Origami Earrings üõçÔ∏è", d: "The ones you've been eyeing.", p: 800 },
            { t: "Full Spa Evening üß∏", d: "The ultimate relaxation.", p: 1200 },
            { t: "Ballet Date ü©∞", d: "Grace and magic night.", p: 2000 }
        ];

        // ============ THREE.JS 3D SCENE ============
        let scene3d, cam3d, ren3d, dogGrp, pathCurve, clock3d;
        let ambientLight, sunLight, fillLight;
        let pathTubeMesh; // Global reference for path coloring
        let locLabels3d = [], targetDogT = 0, currentDogT = 0, sceneReady = false;
        let clickableObjects = [];
        let cloudsArr = [], boatsArr = [], fishArr = [];
        const raycaster = new THREE.Raycaster();
        
        // Camera controls
        // More top-down initial view; increase phi to move camera a bit lower
        let camCtrl = { r: 55, th: 0.6, ph: 1.35 }; // radius, theta, phi
        let camOffset = new THREE.Vector3(0, 0, 0); // Pan offset
        let isDragging = false, lastMouse = { x:0, y:0 }, dragMode = 'rotate'; // 'rotate' or 'pan'

        const locData = [
            { icon: '\uD83C\uDFE0', name: 'Home Base', t: 0 },
            { icon: '\uD83E\uDDC1', name: 'Bakery', t: 0 }, // Cupcake
            { icon: '\uD83C\uDF6B', name: 'Choco Hill', t: 0 },
            { icon: '\uD83D\uDC28', name: 'Koala Corner', t: 0 }, // Koala
            { icon: '\uD83D\uDC3E', name: 'Puppy Park', t: 0 },
            { icon: '\uD83E\uDDCB', name: 'Bubble Tea', t: 0 },
            { icon: '\uD83C\uDF80', name: 'Pink Boutique', t: 0 }, // Ribbon
            { icon: '\uD83D\uDECD\uFE0F', name: 'Shopping City', t: 0 },
            { icon: '\uD83C\uDFAC', name: 'Cozy Cinema', t: 0 }, // Clapper
            { icon: '\uD83C\uDF63', name: 'Sushi Palace', t: 0 },
            { icon: '\uD83C\uDFFA', name: 'Greek Taverna', t: 0 }, // Amphora
            { icon: '\uD83E\uDDDF\u200D\u2640\uFE0F', name: 'Spa Island', t: 0 },
            { icon: 'ü¶´', name: 'Beaver Lodge', t: 0 }, // Beaver
            { icon: '\uD83D\uDC27', name: 'Penguin Iceberg', t: 0 }, // Penguin
            { icon: '\uD83E\uDE70', name: 'Opera House', t: 0 }
        ];

        // Global vertical offset to lift the whole island & sea slightly
        const TERRAIN_VERTICAL_OFFSET = 3.5; // increased to raise terrain and all features
        // Global water level (matches water plane y in mkHill)
        const WATER_LEVEL = 0.2 + TERRAIN_VERTICAL_OFFSET;

        function hillH(x, z) {
            // Mountain shape: combine a sharp central peak with a broad, low base
            // so the top remains cone-like while the lower slopes flatten out.
            const r2 = x*x + z*z;
            // sharp peak (small spread) + broad base (large spread)
            const peak = 20 * Math.exp(-r2 / 80);    // central cone-like peak
            const base = 10 * Math.exp(-r2 / 100);   // broad, low base to flatten lower slopes
            const h = peak + base;
            // Add some noise for ruggedness
            const noise = Math.sin(x) * Math.cos(z) * 0.2;
            // Apply a small vertical offset so terrain and objects appear higher on screen
            return Math.max(0, h + noise + TERRAIN_VERTICAL_OFFSET);
        }

        function init3D() {
            const vp = document.getElementById('viewport');
            // Allow flex layout to control size, but ensure we fill it
            vp.style.width = '100%';
            vp.style.height = '100%'; 
            
            // Get actual dimensions
            const W = vp.clientWidth || 800; 
            const H = vp.clientHeight || 600;
            
            scene3d = new THREE.Scene();
            // Add a soft sky blue background
            scene3d.background = new THREE.Color(0xbfdfff);
            
            cam3d = new THREE.PerspectiveCamera(43, W / H, 0.1, 200);
            
            // Camera position for mountain view - higher and more to the left
            cam3d.position.set(10, 30, 25);
            // Look slightly lower so more terrain/sea appears higher in the view
            cam3d.lookAt(0, 18, 0);

            ren3d = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            ren3d.setClearColor(0x000000, 0); // transparent
            ren3d.setSize(W, H);
            ren3d.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            ren3d.shadowMap.enabled = true;
            ren3d.shadowMap.type = THREE.PCFSoftShadowMap;
            ren3d.toneMapping = THREE.ACESFilmicToneMapping;
            ren3d.toneMappingExposure = 1.2;
            vp.appendChild(ren3d.domElement);
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene3d.add(ambientLight);
            // Keep light colors neutral (white) so scene materials keep their intended colors
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(10, 20, 10); sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048); // Better shadows
            sunLight.shadow.camera.left = -20; sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20; sunLight.shadow.camera.bottom = -20;
            scene3d.add(sunLight);
            fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-5, 3, -5); scene3d.add(fillLight);
            mkHill(); mkPath(); mkDog(); mkLocs(); mkTrees(); mkClouds(); mkBoats(); mkFish();
            clock3d = new THREE.Clock(); sceneReady = true;
            window.addEventListener('resize', () => {
                const w = vp.clientWidth, h = vp.clientHeight;
                cam3d.aspect = w / h; cam3d.updateProjectionMatrix(); ren3d.setSize(w, h);
            });
            
            // Mouse / Touch controls
            const canvas = ren3d.domElement;
            const onDown = (x, y, btn) => { 
                isDragging = true; 
                lastMouse = { x, y }; 
                // Button 1 (middle) or Shift+Left for pan
                dragMode = (btn === 1) ? 'pan' : 'rotate';
            };
            const onMove = (x, y) => {
                if (!isDragging) return;
                const dx = (x - lastMouse.x);
                const dy = (y - lastMouse.y);
                
                if (dragMode === 'rotate') {
                    // Adjust theta/phi OFFSET relative to the automatic dog tracking
                    // We modify camCtrl.th (which is now acting as an offset to dogAngle)
                    camCtrl.th -= dx * 0.005; 
                    camCtrl.ph = Math.max(0.1, Math.min(Math.PI/2 - 0.1, camCtrl.ph - dy * 0.005)); 
                } else if (dragMode === 'pan') {
                    // Pan relative to camera view
                    const sensitivity = camCtrl.r * 0.002;

                    // Simplified: Move Right/Left relative to camera
                    const vRight = new THREE.Vector3(1, 0, 0).applyQuaternion(cam3d.quaternion);
                    const vUp = new THREE.Vector3(0, 1, 0).applyQuaternion(cam3d.quaternion);
                    
                    const dV = vRight.multiplyScalar(-dx * sensitivity).add(vUp.multiplyScalar(dy * sensitivity));
                    
                    camOffset.add(dV);
                    
                    // Limits
                    camOffset.x = Math.max(-20, Math.min(20, camOffset.x));
                    camOffset.y = Math.max(-10, Math.min(20, camOffset.y));
                    camOffset.z = Math.max(-20, Math.min(20, camOffset.z));
                }
                
                lastMouse = { x, y };
            };
            const onUp = () => { isDragging = false; };
            
            canvas.addEventListener('mousedown', e => onDown(e.clientX, e.clientY, e.button));
            window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', onUp);

            canvas.addEventListener('click', e => {
                const rect = canvas.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera({ x, y }, cam3d);
                const intersects = raycaster.intersectObjects(clickableObjects, true);
                if (intersects.length > 0) {
                    let target = intersects[0].object;
                    while(target && (!target.userData || !target.userData.isLoc)) {
                        target = target.parent;
                    }
                    if (target && target.userData && target.userData.loc) {
                        showLocDetail(target.userData.loc);
                    }
                }
            });
            
            // Enhanced Touch Support (One finger rotate, two fingers pan)
            const getTouchCenter = (touches) => {
                if(touches.length === 2) {
                    return { x: (touches[0].clientX + touches[1].clientX)/2, y: (touches[0].clientY + touches[1].clientY)/2 };
                }
                return { x: touches[0].clientX, y: touches[0].clientY };
            };

            canvas.addEventListener('touchstart', e => { 
                e.preventDefault();
                if(e.touches.length === 1) {
                    onDown(e.touches[0].clientX, e.touches[0].clientY, 0); // 0 = rotate
                } else if (e.touches.length === 2) {
                    const c = getTouchCenter(e.touches);
                    onDown(c.x, c.y, 1); // 1 = pan
                }
            }, {passive:false});
            
            window.addEventListener('touchmove', e => { 
                if(!isDragging) return;
                e.preventDefault();
                
                if(e.touches.length === 1 && dragMode === 'rotate') {
                    onMove(e.touches[0].clientX, e.touches[0].clientY);
                } else if(e.touches.length === 2 && dragMode === 'pan') {
                    const c = getTouchCenter(e.touches);
                    onMove(c.x, c.y);
                }
            }, {passive:false});
            
            window.addEventListener('touchend', onUp);
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                // Allow much larger zoom-out range (increase upper limit)
                camCtrl.r = Math.max(5, Math.min(200, camCtrl.r + e.deltaY * 0.01));
            }, {passive:false});
            
            // Re-frame button
            const btn = document.createElement('div');
            btn.innerHTML = 'üéØ';
            btn.style.cssText = 'position:absolute; bottom:20px; right:20px; font-size:24px; cursor:pointer; background:white; width:40px; height:40px; border-radius:50%; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 10px rgba(0,0,0,0.2); z-index:100;';
            btn.title = "Re-frame on Dog";
            btn.onclick = () => {
                camOffset.set(0, 0, 0);
                camCtrl = { r: 18, th: 0.3, ph: 1.2 };
            };
            vp.appendChild(btn);

            animLoop();
        }

        // Update sky color and lighting based on local clock time.
        function updateSkyByTime() {
            if (!scene3d || !ambientLight || !sunLight || !fillLight) return;
            const now = new Date();
            const h = now.getHours() + now.getMinutes()/60;

            // Dawn/Dusk smoothing windows
            const dawnStart = 5, dawnEnd = 8;
            const duskStart = 17, duskEnd = 20;
            let t = 0;
            if (h >= dawnEnd && h < duskStart) t = 1; // day
            else if (h >= dawnStart && h < dawnEnd) t = (h - dawnStart) / (dawnEnd - dawnStart);
            else if (h >= duskStart && h < duskEnd) t = 1 - (h - duskStart) / (duskEnd - duskStart);
            else t = 0; // night

            // Colors
            const dayColor = new THREE.Color(0xbfdfff); // soft sky blue
            const duskColor = new THREE.Color(0xffc28a); // warm dusk
            const nightColor = new THREE.Color(0x081229); // deep night

            // Interpolate sky color: use duskColor as mid transition for smoother look
            let skyCol = new THREE.Color();
            if (t >= 0.5) {
                // blend between day and dusk for late/early day
                skyCol.copy(dayColor).lerp(duskColor, 1 - (t - 0.5) * 2);
            } else {
                // blend between night and dusk for early/late night
                skyCol.copy(nightColor).lerp(duskColor, t * 2);
            }

            scene3d.background = skyCol;

            // Light intensities: day stronger, night weaker
            ambientLight.intensity = 0.05 + 0.85 * t; // 0.15..1.0
            sunLight.intensity = 0.05 + 0.95 * t; // 0.05..1.0
            fillLight.intensity = 0.05 + 0.5 * t;

            // Keep lights neutral white so material colors remain stable.
            // We only vary intensities above; do NOT tint lights by sky color.
            ambientLight.color.setHex(0xffffff);
            sunLight.color.setHex(0xffffff);
            fillLight.color.setHex(0xffffff);
        }

        function mkHill() {
            // Create a subdivided plane for the mountain
            // 40x40 size, with lots of segments for smooth height
            const geo = new THREE.PlaneGeometry(80, 80, 128, 128);
            geo.rotateX(-Math.PI / 2); // Lay flat on XZ plane

            const posAttribute = geo.attributes.position;
            const vertex = new THREE.Vector3();

            for (let i = 0; i < posAttribute.count; i++) {
                vertex.fromBufferAttribute(posAttribute, i);
                
                const dist = Math.sqrt(vertex.x*vertex.x + vertex.z*vertex.z);
                
                // Construct a rounded island logic:
                // If the vertex is far from center, drop it down underwater to hide square plane corners
                // Use a smaller base radius so the island footprint is tighter: outer cutoff ~28, taper between 26..28
                if (dist > 28) {
                    vertex.y = -5;
                } else {
                    // Apply height function
                    let h = hillH(vertex.x, vertex.z);
                    
                    // Smooth taper at the edge to ensure no jagged drops
                    if (dist > 26) {
                        // Blend from h to slightly negative between r=26 and r=28
                        const t = (dist - 26) / 2;
                        h = h * (1 - t) - 1.0 * t;
                    }
                    vertex.y = h;
                }
                
                // Update the attribute
                posAttribute.setY(i, vertex.y);
            }
            
            // Remove faces that are entirely underwater to create a round island shape
            const oldIndices = geo.index.array;
            const newIndices = [];
            const waterLevel = WATER_LEVEL; // Use global water level so trimming matches actual water plane
            
            for (let i = 0; i < oldIndices.length; i += 3) {
                const a = oldIndices[i];
                const b = oldIndices[i+1];
                const c = oldIndices[i+2];
                
                const ya = posAttribute.getY(a);
                const yb = posAttribute.getY(b);
                const yc = posAttribute.getY(c);
                
                // Keep the face if at least one vertex is above (or near) the water level
                // We use a small epsilon -0.1 to allow faces that are just crossing the surface
                if (ya >= waterLevel - 0.01 || yb >= waterLevel - 0.01 || yc >= waterLevel - 0.01) {
                    newIndices.push(a, b, c);
                }
            }
            geo.setIndex(newIndices);
            
            geo.computeVertexNormals(); // Recalculate normals for lighting

            const mat = new THREE.MeshLambertMaterial({ 
                color: 0x5cb338,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.receiveShadow = true; 
            mesh.name = "ground_mesh";
            scene3d.add(mesh);
            
            // Optional: Add a water plane at y=0 or slightly below
            const waterGeo = new THREE.CircleGeometry(52, 128);
            waterGeo.rotateX(-Math.PI / 2);
            const waterMat = new THREE.MeshPhongMaterial({ 
                color: 0x0066cc, 
                transparent: true, 
                opacity: 0.9,
                shininess: 80
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            // Use global WATER_LEVEL so water always matches terrain offset
            water.position.y = WATER_LEVEL;
            scene3d.add(water);
        }

        function mkPath() {
            // Spiral path up the mountain
            const numPoints = 100;
            const turns = 3.5; // Number of times to wrap around
            const startRadius = 14;
            const endRadius = 1;
            
            const pts = [];
            for(let i=0; i<numPoints; i++) {
                const t = i / (numPoints - 1);
                // Radius gets smaller as we go up
                const r = startRadius * (1 - t) + endRadius * t;
                // Angle spirals around
                const angle = t * Math.PI * 2 * turns; 
                
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                // Get terrain height
                const y = hillH(x, z);
                
                // Offset slightly above terrain
                pts.push(new THREE.Vector3(x, y + 0.2, z));
            }
            
            pathCurve = new THREE.CatmullRomCurve3(pts);
            
            // Draw the path using TubeGeometry with Vertex Colors
            const geo = new THREE.TubeGeometry(pathCurve, 200, 0.4, 8, false);
            const colors = [];
            for (let i = 0; i < geo.attributes.position.count; i++) {
                // Initial color (Sand)
                colors.push(0.76, 0.62, 0.44);
            }
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            pathTubeMesh = new THREE.Mesh(
                geo,
                new THREE.MeshLambertMaterial({ vertexColors: true, color: 0xffffff, side: THREE.DoubleSide })
            );
            pathTubeMesh.receiveShadow = true; 
            scene3d.add(pathTubeMesh);

            // Cap the ends so it doesn't look hollow
            const startPt = pathCurve.getPointAt(0);
            const endPt = pathCurve.getPointAt(1);
            
            const startCap = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshLambertMaterial({ color: 0xc29e70 }));
            startCap.position.copy(startPt);
            startCap.name = "path_start_cap";
            scene3d.add(startCap);

            const endCap = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), new THREE.MeshLambertMaterial({ color: 0xc29e70 }));
            endCap.position.copy(endPt);
            endCap.name = "path_end_cap";
            scene3d.add(endCap);
        }

        function mkDog() {
            dogGrp = new THREE.Group();
            const blk = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const wht = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const nos = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.5, 0.5), blk);
            body.position.set(0, 0.5, 0); body.castShadow = true; dogGrp.add(body);
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.4, 0.52), wht);
            chest.position.set(0.35, 0.5, 0); dogGrp.add(chest);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.38, 0.42), blk);
            head.position.set(0.6, 0.85, 0); head.castShadow = true; dogGrp.add(head);
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.18, 0.28), wht);
            snout.position.set(0.8, 0.78, 0); dogGrp.add(snout);
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), nos);
            nose.position.set(0.92, 0.82, 0); dogGrp.add(nose);
            [0.14, -0.14].forEach(z => {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.045, 8, 8), wht);
                eye.position.set(0.78, 0.95, z); dogGrp.add(eye);
                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.02, 8, 8), blk);
                pupil.position.set(0.82, 0.95, z); dogGrp.add(pupil);
            });
            [-1, 1].forEach(s => {
                const ear = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.18, 0.1), blk);
                ear.position.set(0.52, 1.08, s * 0.17); ear.rotation.z = 0.3; dogGrp.add(ear);
            });
            dogGrp.legs = [];
            [[-1, wht, 0.3, 0.18], [1, wht, 0.3, -0.18],
             [1, blk, -0.3, 0.18], [-1, blk, -0.3, -0.18]].forEach(([pair, mat, x, z]) => {
                const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.35, 0.1), mat);
                leg.position.set(x, 0.18, z); leg.castShadow = true;
                dogGrp.add(leg); dogGrp.legs.push({ mesh: leg, pair: pair });
            });
            dogGrp.tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.05, 0.35, 6), blk);
            dogGrp.tail.position.set(-0.55, 0.8, 0);
            dogGrp.tail.geometry.translate(0, 0.15, 0);
            dogGrp.add(dogGrp.tail);
            const tip = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), wht);
            tip.position.set(0, 0.22, 0); dogGrp.tail.add(tip);
            dogGrp.scale.set(0.7, 0.7, 0.7);
            scene3d.add(dogGrp);
            // Place the dog on the path at t=0 (start)
            // Use getPointAt (ArcLength) to match TubeGeometry texture coordinates
            const dogStart = pathCurve.getPointAt(0); 
            dogGrp.position.copy(dogStart);
            dogGrp.position.y += 0.4; // Stand ON TOP of the path tube
        }

        function mkLocObject(name) {
            const grp = new THREE.Group();
            const mCol = (c) => new THREE.MeshLambertMaterial({ color: c });
            
            if (name === 'Home Base') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), mCol(0xeeeeee));
                base.position.y = 0.3; base.castShadow = true; grp.add(base);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), mCol(0xff4444));
                roof.position.y = 0.85; roof.rotation.y = Math.PI/4; roof.castShadow = true; grp.add(roof);
                const door = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.4), mCol(0x654321));
                door.position.set(0, 0.3, 0.41); grp.add(door);
            } else if (name === 'Choco Hill') {
                 const bar = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.5), mCol(0x5D4037));
                 bar.position.y = 0.15; bar.castShadow = true; grp.add(bar);
                 for(let i=-1; i<=1; i+=2) {
                     for(let j=-1; j<=1; j+=2) {
                         const b = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.2), mCol(0x4E342E));
                         b.position.set(i*0.2, 0.25, j*0.12); b.castShadow = true; grp.add(b);
                     }
                 }
            } else if (name === 'Puppy Park') {
                const boneMat = mCol(0xffffff);
                const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8), boneMat);
                shaft.rotation.z = Math.PI/2; shaft.position.y = 0.2; shaft.castShadow = true; grp.add(shaft);
                [-0.3, 0.3].forEach(x => {
                    [-0.1, 0.1].forEach(z => {
                         const ball = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), boneMat);
                         ball.position.set(x, 0.2, z); ball.castShadow = true; grp.add(ball);
                    });
                });
            } else if (name === 'Bubble Tea') {
                const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.5, 12), mCol(0xFFCCBC));
                cup.position.y = 0.25; cup.castShadow = true; grp.add(cup);
                const lid = new THREE.Mesh(new THREE.SphereGeometry(0.21, 12, 8, 0, Math.PI*2, 0, Math.PI/2), mCol(0xFFFFFF)); 
                lid.position.y = 0.5; lid.castShadow = true; grp.add(lid);
                const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8), mCol(0x333333));
                straw.position.set(0.05, 0.5, 0); straw.rotation.z = -0.2; straw.castShadow = true; grp.add(straw);
            } else if (name === 'Shopping City') {
                const bag = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.3), mCol(0xFFA726));
                bag.position.y = 0.25; bag.castShadow = true; grp.add(bag);
                const handle = new THREE.Mesh(new THREE.TorusGeometry(0.1, 0.02, 6, 12, Math.PI), mCol(0x3E2723));
                handle.position.set(0, 0.5, 0); grp.add(handle);
            } else if (name === 'Sushi Palace') {
                const rice = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.25, 12), mCol(0xffffff));
                rice.rotation.x = Math.PI/2; rice.position.y = 0.3; rice.castShadow = true; grp.add(rice);
                const nori = new THREE.Mesh(new THREE.CylinderGeometry(0.31, 0.31, 0.15, 12, 1, true), new THREE.MeshLambertMaterial({ color: 0x1a1a1a, side: THREE.DoubleSide }));
                nori.rotation.x = Math.PI/2; nori.position.y = 0.3; grp.add(nori);
                const fill = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.26, 8), mCol(0xFF5722));
                fill.rotation.x = Math.PI/2; fill.position.y = 0.3; grp.add(fill);
            } else if (name === 'Spa Island') {
                [0.35, 0.25, 0.15].forEach((r, i) => {
                     const st = new THREE.Mesh(new THREE.SphereGeometry(r, 12, 8), mCol(0x9E9E9E));
                     st.scale.y = 0.6;
                     st.position.y = (i===0 ? 0.1 : (i===1 ? 0.35 : 0.55));
                     st.castShadow = true;
                     grp.add(st);
                });
            } else if (name === 'Opera House') {
                 // Steps
                 const step1 = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.8), mCol(0xEEEEEE));
                 step1.position.y = 0.05; grp.add(step1);
                 const step2 = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 0.6), mCol(0xEEEEEE));
                 step2.position.y = 0.15; grp.add(step2);
                 // Main Building
                 const build = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.4), mCol(0xF5F5F5));
                 build.position.y = 0.45; grp.add(build);
                 // Pillars
                 [-0.3, -0.1, 0.1, 0.3].forEach(x => {
                     const p = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.5, 8), mCol(0xDDDDDD));
                     p.position.set(x, 0.45, 0.22); grp.add(p);
                 });
                 // Gold Dome
                 const dome = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI*2, 0, Math.PI/2), mCol(0xFFD700)); // Gold
                 dome.position.y = 0.7; grp.add(dome);
            } else if (name === 'Bakery') {
                // Cupcake Building (Smaller & Cute)
                const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.4, 16), mCol(0xFFC0CB)); 
                cup.position.y = 0.2; cup.castShadow = true; grp.add(cup);
                // Frosting Dome
                const dome = new THREE.Mesh(new THREE.SphereGeometry(0.38, 16, 16, 0, Math.PI*2, 0, Math.PI/2), mCol(0xFFFFFF)); 
                dome.position.y = 0.4; grp.add(dome);
                // Sprinkles
                [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00].forEach((c, i) => {
                    const s = new THREE.Mesh(new THREE.CapsuleGeometry(0.025, 0.05, 4, 4), mCol(c));
                    s.position.set(Math.sin(i*2)*0.2, 0.65 + Math.cos(i)*0.03, Math.cos(i*2)*0.2);
                    s.rotation.set(Math.random(), Math.random(), Math.random());
                    grp.add(s);
                });
                // Cherry
                const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mCol(0xD32F2F));
                cherry.position.set(0, 0.78, 0); grp.add(cherry);
            } else if (name === 'Koala Corner') {
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.7, 8), mCol(0x8B4513));
                trunk.position.y = 0.35; trunk.castShadow = true; grp.add(trunk);
                // Round canopy (Deciduous)
                const leavesMat = mCol(0x4CAF50); 
                const l1 = new THREE.Mesh(new THREE.IcosahedronGeometry(0.4, 0), leavesMat);
                l1.position.y = 0.8; grp.add(l1);
                [0, 2, 4].forEach(i => {
                    const l = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), leavesMat);
                    l.position.set(Math.sin(i)*0.3, 0.7, Math.cos(i)*0.3);
                    grp.add(l);
                });
                
                // Koala
                const kBody = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), mCol(0x9E9E9E)); 
                kBody.position.set(0, 0.5, 0.16); grp.add(kBody); // Sitting on trunk
                const kHead = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), mCol(0x9E9E9E));
                kHead.position.set(0, 0.62, 0.19); grp.add(kHead);
                const kEarL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), mCol(0x9E9E9E));
                kEarL.position.set(-0.07, 0.68, 0.18); grp.add(kEarL);
                const kEarR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), mCol(0x9E9E9E));
                kEarR.position.set(0.07, 0.68, 0.18); grp.add(kEarR);
            } else if (name === 'Pink Boutique') {
                const build = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.5), mCol(0xFFFFFF));
                build.position.y = 0.3; build.castShadow = true; grp.add(build);
                const roof = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.6), mCol(0xFF69B4));
                roof.position.y = 0.65; grp.add(roof);
                const bow = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), mCol(0xFF69B4));
                bow.position.set(0, 0.75, 0); grp.add(bow);
            } else if (name === 'Cozy Cinema') {
                const screen = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.1), mCol(0x000000));
                screen.position.set(0, 0.4, -0.2); grp.add(screen);
                const proj = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.4, 16), mCol(0x333333));
                proj.rotation.x = Math.PI/2; proj.position.set(0, 0.4, 0.4); grp.add(proj);
            } else if (name === 'Greek Taverna') {
                const floor = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.8), mCol(0xDDDDDD));
                floor.position.y = 0.05; grp.add(floor);
                [-0.3, 0.3].forEach(x => {
                    [-0.3, 0.3].forEach(z => {
                        const col = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8), mCol(0xFFFFFF));
                        col.position.set(x, 0.35, z); grp.add(col);
                    });
                });
                const dome = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI*2, 0, Math.PI/2), mCol(0x0099FF)); 
                dome.position.y = 0.65; grp.add(dome);
            } else if (name === 'Beaver Lodge') {
                // Two wood pieces (logs)
                const logGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.7, 8);
                const woodMat = mCol(0x5D4037);
                
                const log1 = new THREE.Mesh(logGeo, woodMat);
                log1.rotation.z = Math.PI / 2; // Lay flat
                log1.rotation.y = Math.PI / 8; // Slight angle
                log1.position.y = 0.12;
                log1.castShadow = true;
                grp.add(log1);
                
                const log2 = new THREE.Mesh(logGeo, woodMat);
                log2.rotation.z = Math.PI / 2;
                log2.rotation.y = -Math.PI / 4; // Cross it
                log2.position.y = 0.24; // Stacked on top
                log2.castShadow = true;
                grp.add(log2);
            } else if (name === 'Penguin Iceberg') {
                const ice = new THREE.Mesh(new THREE.ConeGeometry(0.6, 0.7, 5), mCol(0xE0F7FA));
                ice.position.y = 0.35; grp.add(ice);
                const pBody = new THREE.Mesh(new THREE.CapsuleGeometry(0.1, 0.2, 4, 8), mCol(0x1a1a1a));
                pBody.position.set(0.2, 0.2, 0.2); grp.add(pBody);
                const pBelly = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.15, 4, 8), mCol(0xffffff));
                pBelly.position.set(0.22, 0.2, 0.22); grp.add(pBelly);
            }
            else {
                const box = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), mCol(0x888888));
                box.position.y=0.25; grp.add(box);
            }
            return grp;
        }

        function toggleLocMenu() {
            const m = document.getElementById('loc-list-hud');
            if(m) m.classList.toggle('show');
        }

        function updateLocMenu() {
            const hud = document.getElementById('loc-list-hud');
            if(!hud) return;
            
            // Clear existing items (keep title if we want, or just rebuild all)
            hud.innerHTML = '<div class="loc-list-title">Destinations</div>';
            
            locData.forEach(loc => {
                const feat = locFeatures[loc.name];
                const unlocked = feat ? (coins >= feat.unlockCoins || total >= feat.unlockCoins) : true;
                
                const item = document.createElement('div');
                item.className = 'loc-list-item ' + (unlocked ? 'unlocked' : 'locked');
                item.onclick = () => {
                    showLocDetail(loc);
                    if(window.innerWidth < 600) toggleLocMenu(); // Auto-close on mobile
                };
                
                let html = `<span>${loc.icon}</span> ${loc.name}`;
                if(!unlocked) {
                    html += `<div class="lock-icon">üîí</div>`;
                }
                item.innerHTML = html;
                hud.appendChild(item);
            });
        }

        function mkLocs() {
            const vp = document.getElementById('viewport');
            
            // 1. Create Menu Button
            if(!document.getElementById('loc-menu-btn')) {
                const btn = document.createElement('div');
                btn.id = 'loc-menu-btn';
                btn.className = 'loc-menu-btn';
                btn.innerHTML = 'üó∫Ô∏è Locations';
                btn.onclick = toggleLocMenu;
                vp.appendChild(btn);
            }

            // 2. Create Menu Container
            if(!document.getElementById('loc-list-hud')) {
                const hud = document.createElement('div');
                hud.id = 'loc-list-hud';
                hud.className = 'loc-list-hud';
                vp.appendChild(hud);
            }

            // 3. Initial Populate
            updateLocMenu();

            locData.forEach((loc, idx) => {
                const t = idx / (locData.length - 1);
                // Point on Path
                const p = pathCurve.getPointAt(t);
                
                // Place on the path, but "higher" (on top of the tube)
                const pathSurfaceY = p.y + 0.4; 
                
                // 3D Object
                const obj = mkLocObject(loc.name);
                // Scale normal - User requested BIGGER
                obj.scale.set(1.5, 1.5, 1.5); 
                obj.position.set(p.x, pathSurfaceY, p.z);
                
                // Rotate to align with path tangent
                const tan = pathCurve.getTangentAt(t);
                obj.rotation.y = Math.atan2(tan.x, tan.z); // Face along path
                
                obj.userData = { loc: loc, isLoc: true };
                scene3d.add(obj);
                clickableObjects.push(obj);

                // If the object sits into the terrain (overlap), nudge it outward radially until it sits above ground.
                (function ensureAboveTerrain(o) {
                    const clearance = 0.12; // desired minimum clearance above ground
                    let ox = o.position.x, oz = o.position.z;
                    let groundHere = hillH(ox, oz);
                    // If base (approx) is below or too close to ground, move outward
                    if (o.position.y <= groundHere + clearance) {
                        const angle = Math.atan2(oz, ox);
                        let radius = Math.sqrt(ox*ox + oz*oz);
                        let moved = false;
                        for (let step = 0; step < 24; step++) {
                            radius += 0.9 + Math.random() * 0.6; // push outward
                            const nx = Math.cos(angle) * radius;
                            const nz = Math.sin(angle) * radius;
                            const newGround = hillH(nx, nz);
                            const newY = newGround + 0.4; // keep object sitting above terrain
                            // if the new location yields enough clearance, adopt it
                            if (newY > newGround + clearance) {
                                o.position.set(nx, newY, nz);
                                moved = true;
                                break;
                            }
                        }
                        if (!moved) {
                            // fallback: small outward nudge
                            const nx = Math.cos(angle) * (radius + 1.2);
                            const nz = Math.sin(angle) * (radius + 1.2);
                            const newGround = hillH(nx, nz);
                            o.position.set(nx, newGround + 0.4, nz);
                        }
                    }
                })(obj);

                // Label (With Emoji + Name)
                const lbl = document.createElement('div');
                lbl.className = 'loc-label-3d';
                lbl.innerHTML = '<span class="loc-icon-3d">' + loc.icon + '</span><span class="loc-tag-3d">' + loc.name + '</span>';
                lbl.addEventListener('click', () => showLocDetail(loc));
                vp.appendChild(lbl);
                
                // Label float position above the object
                // Store object ref for proximity check
                locLabels3d.push({ el: lbl, world: new THREE.Vector3(obj.position.x, obj.position.y + 1.6, obj.position.z), loc: loc, obj: obj });
            });
        }

        function mkTrees() {
            // Darker, more saturated foliage and trunk
            const tg = new THREE.MeshLambertMaterial({ color: 0x1e7f2e });
            const tk = new THREE.MeshLambertMaterial({ color: 0x5A3E2A });
            const terrainMesh = scene3d.getObjectByName("ground_mesh");
            const terrainY = terrainMesh ? terrainMesh.position.y : 0;
            
            const pathPts = pathCurve.getPoints(100);
            // Increase max trees and sample radius by area so trees appear more evenly across the island
            let treesPlaced = 0, attempts = 0;
            const MAX_TREES = 180;
            
            while(treesPlaced < MAX_TREES && attempts < 1500) {
                attempts++;
                const angle = Math.random() * Math.PI * 2;
                // Match tree radius to the new, smaller island base
                const maxTreeR = 28; // maximum radial distance for trees
                // Choose r proportional to sqrt(u) for even area distribution
                const r = maxTreeR * Math.sqrt(Math.random());
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                let safe = true;
                const distSq = x*x + z*z;
                // Avoid center top
                if (distSq < 0.4) continue; // allow trees closer to summit than before
                
                // Avoid water / shoreline (keep trees strictly on the main island part)
                // Keep trees within the island area to avoid shoreline: use maxTreeR
                if (distSq > (maxTreeR * maxTreeR)) continue;
                
                // Also check height just in case ‚Äî avoid planting in water
                if (hillH(x, z) < WATER_LEVEL + 0.05) continue;

                // Path collision
                for(let p of pathPts) {
                    // Reduce exclusion distance so trees can live closer to the path on upper slopes
                    if ((p.x-x)**2 + (p.z-z)**2 < 1.2) { safe = false; break; }
                }
                if(!safe) continue;
                
                // Location collision
                for(let l of locLabels3d) {
                    // Allow trees closer to locations but still avoid direct overlap
                    if ((l.world.x-x)**2 + (l.world.z-z)**2 < 3) { safe = false; break; }
                }
                if(!safe) continue;

                treesPlaced++;
                const y = hillH(x, z) + terrainY + 0.05;
                const th = 0.4 + Math.random() * 0.3;
                const treeGrp = new THREE.Group();
                
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.09, th, 5), tk);
                trunk.position.set(0, th/2, 0); trunk.castShadow = true; treeGrp.add(trunk);
                
                const layers = 2 + Math.floor(Math.random() * 2);
                for (let l = 0; l < layers; l++) {
                    const tr = 0.45 - l * 0.1 + Math.random() * 0.08;
                    const thh = 0.55 + Math.random() * 0.15;
                    const c = new THREE.Mesh(new THREE.ConeGeometry(tr, thh, 6), tg);
                    c.position.set(0, th + l * 0.3 + 0.15, 0); c.castShadow = true; treeGrp.add(c);
                }
                treeGrp.position.set(x, y, z);
                scene3d.add(treeGrp);
            }

            const fc = [0xff69b4, 0xff2d55, 0xffeb3b, 0xff9800, 0xba68c8];
            for (let i = 0; i < 30; i++) {
                const t = Math.random(), pt = pathCurve.getPoint(t);
                const ox = (Math.random()-0.5)*2.5, oz = (Math.random()-0.5)*1.5;
                const fx = pt.x+ox, fz = pt.z+oz;
                // Very simple check for flowers
                if (Math.abs(ox) < 0.3 && Math.abs(oz) < 0.3) continue; // Don't put on path center

                // Don't place flowers underwater
                if (hillH(fx, fz) < WATER_LEVEL + 0.02) continue;

                const fy = hillH(fx, fz) + terrainY;
                const fl = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05+Math.random()*0.03, 6, 6),
                    new THREE.MeshLambertMaterial({ color: fc[Math.floor(Math.random()*fc.length)] })
                );
                fl.position.set(fx, fy+0.05, fz); scene3d.add(fl);
            }
        }

        function mkClouds() {
            const cm = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
            // Spread clouds far apart and place them lower, more transparent
            // const cloudPositions = [[-30,16,-40],[20,15,35],[50,17,-45],[-50,16,25],[35,15,-20],[-25,17,50],[55,16,-15]];
            const cloudPositions = [[-20,22,-20],[20,30,25],[40,45,-25],[-30,37,25],[35,42,-30],[-25,63,50],[35,31,-15]];
            cloudPositions.forEach(([x,y,z], idx) => {
                const cg = new THREE.Group();
                for (let i = 0; i < 4+Math.floor(Math.random()*3); i++) {
                    // larger cloud puffs for a puffier silhouette
                    const r = 1.0 + Math.random() * 1.6;
                    const pf = new THREE.Mesh(new THREE.SphereGeometry(r, 10, 8), cm);
                    pf.position.set((Math.random()*2-1)*1.5, Math.random()*0.6 - 0.2, Math.random()*1.6-0.6 +4.0);
                    pf.castShadow = false; pf.receiveShadow = false;
                    cg.add(pf);
                }
                // Place clouds high above terrain, no movement
                cg.position.set(x, y, z);
                // scale up the whole cloud group slightly for more presence
                const s = 1.2 + Math.random() * 0.6;
                cg.scale.set(s, s, s);
                // No movement data needed - clouds are stationary
                cg.userData = {};
                cloudsArr.push(cg);
                scene3d.add(cg);
            });
        }

        function mkBoats() {
            // Simple small boats that float on the water and slowly orbit
            const boatCount = 7; // increased count
            const waterRadius = 52; // matches water geometry radius
            for (let i = 0; i < boatCount; i++) {
                const grp = new THREE.Group();
                const hull = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.22, 0.65), new THREE.MeshPhongMaterial({ color: 0x663300 }));
                hull.position.y = 0;
                grp.add(hull);
                const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 1.0, 6), new THREE.MeshLambertMaterial({ color: 0x331a00 }));
                mast.position.y = 0.56; grp.add(mast);
                const sail = new THREE.Mesh(new THREE.PlaneGeometry(0.75, 0.56), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                sail.position.set(0.19, 0.5, 0); sail.rotation.y = 0.1; grp.add(sail);

                // place on water with circular motion parameters
                const ang = Math.random() * Math.PI * 2;
                const r = (waterRadius - 6) * (0.4 + Math.random() * 0.55);
                grp.position.set(Math.cos(ang) * r, WATER_LEVEL, Math.sin(ang) * r);
                // ensure initial placement is over water (not shallow terrain)
                const tx = grp.position.x, tz = grp.position.z;
                if (hillH(tx, tz) > WATER_LEVEL - 0.05) {
                    // push boat outward to deeper water
                    grp.userData = { angle: ang, radius: Math.min(waterRadius - 3, r + 6), speed: 0.03 * (0.8 + Math.random() * 1.0) };
                    grp.position.set(Math.cos(ang) * grp.userData.radius, WATER_LEVEL, Math.sin(ang) * grp.userData.radius);
                } else {
                    // slightly faster default speeds for a gentle drift (use dt-based update in loop)
                    grp.userData = { angle: ang, radius: r, speed: 0.03 * (0.8 + Math.random() * 1.0) };
                }
                boatsArr.push(grp);
                scene3d.add(grp);
            }
        }

        function mkFish() {
            // Fish are small colored cones that swim under the water surface
            const fishCount = 18;
            const waterRadius = 52;
            for (let i = 0; i < fishCount; i++) {
                const body = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.4, 8), new THREE.MeshLambertMaterial({ color: 0xff9933 }));
                // orient cone along X so we'll rotate later
                body.rotation.z = Math.PI;
                const ang = Math.random() * Math.PI * 2;
                const r = (waterRadius - 8) * Math.sqrt(Math.random()) * 0.8;
                const depth = WATER_LEVEL - (0.5 + Math.random() * 1.8);
                body.position.set(Math.cos(ang) * r, depth, Math.sin(ang) * r);
                body.userData = { angle: ang, radius: r, speed: 0.6 * (0.3 + Math.random() * 0.9), depthBase: depth };
                fishArr.push(body);
                scene3d.add(body);
            }
        }

        function updateDog3D(t) { if (sceneReady) targetDogT = Math.min(Math.max(t, 0), 1); }

        function animLoop() {
            requestAnimationFrame(animLoop);
            if (!sceneReady) return;
            // Update sky and lights every frame (cheap) so real-time clock affects scene
            updateSkyByTime();
            const dt = clock3d.getDelta(), el = clock3d.getElapsedTime();
            currentDogT += (targetDogT - currentDogT) * Math.min(dt * 2, 1);
            if (pathCurve && dogGrp) {
                // Use getPointAt (ArcLength) to match TubeGeometry coloring
                const pos = pathCurve.getPointAt(currentDogT);
                dogGrp.position.copy(pos);
                dogGrp.position.y += 0.4; // Stand ON TOP of the path tube
                
                // Color Path Progress
                if(pathTubeMesh) {
                    const colors = pathTubeMesh.geometry.attributes.color;
                    const count = colors.count; // Vertices
                    const rings = 201; // 200 Segments + 1
                    
                    // Use Ceil to ensure gold extends fully to/under the dog
                    const currentRing = Math.ceil(currentDogT * (rings - 1));
                    const vertsPerRing = count / rings; 
                    
                    // c1: GOLD (Done) | c2: SAND (Future)
                    const c1 = { r: 1.0, g: 0.84, b: 0.0 }; // Gold
                    const c2 = { r: 0.76, g: 0.62, b: 0.44 }; // Sand
                    
                    for(let i=0; i<count; i++) {
                        const rIndex = Math.floor(i / vertsPerRing);
                        if (rIndex <= currentRing) {
                             colors.setXYZ(i, c1.r, c1.g, c1.b);
                        } else {
                             colors.setXYZ(i, c2.r, c2.g, c2.b);
                        }
                    }
                    colors.needsUpdate = true;
                }

                const lt = Math.min(currentDogT + 0.01, 1);
                const lp = pathCurve.getPointAt(lt); // Use getPointAt here too
                const dir = new THREE.Vector3().subVectors(lp, pos);
                if (dir.lengthSq() > 0.0001) dogGrp.rotation.y = Math.atan2(dir.x, dir.z) - Math.PI/2;
                const moving = Math.abs(targetDogT - currentDogT) > 0.001;
                const sw = Math.sin(el * (moving ? 8 : 0)) * 0.4;
                dogGrp.legs.forEach(l => { l.mesh.rotation.x = sw * l.pair; });
                if (dogGrp.tail) dogGrp.tail.rotation.z = Math.sin(el * 5) * 0.4;
                dogGrp.position.y += Math.sin(el * (moving ? 8 : 2)) * (moving ? 0.04 : 0.015);
            }
            const vp = document.getElementById('viewport');
            const W = vp.clientWidth, H = vp.clientHeight;
            locLabels3d.forEach(({ el: lbl, world, obj }) => {
                // Occlusion Check (Raycast from Camera)
                const ground = scene3d.getObjectByName("ground_mesh");
                let visible = true;
                if(ground) {
                    const dir = new THREE.Vector3().subVectors(obj.position, cam3d.position);
                    const distToObj = dir.length();
                    raycaster.set(cam3d.position, dir.normalize());
                    const hits = raycaster.intersectObject(ground);
                    // If terrain blocks view (hit is closer than object)
                    if(hits.length > 0 && hits[0].distance < distToObj - 2.0) {
                         visible = false;
                    }
                }

                // Proximity Check for visual indication
                let dist = 999;
                if(dogGrp && obj) {
                    dist = dogGrp.position.distanceTo(obj.position);
                }
                
                // If close (e.g. within 3.0 units)
                if(dist < 3.0) {
                    lbl.classList.add('loc-active'); 
                    
                    // Make transparent using CLONED material to avoid shared-material issues
                    obj.traverse(c => {
                        if(c.isMesh) {
                            if(!c.userData.isTransparentMode) {
                                c.userData.originalMat = c.material;
                                const m = c.material.clone();
                                m.transparent = true;
                                m.opacity = 0.25;
                                c.material = m;
                                c.userData.isTransparentMode = true;
                            }
                        }
                    });
                } else {
                    lbl.classList.remove('loc-active');
                    
                    // Reset to original material
                    obj.traverse(c => {
                        if(c.isMesh && c.userData.isTransparentMode) {
                            c.material.dispose(); // Start fresh next time
                            c.material = c.userData.originalMat;
                            c.userData.isTransparentMode = false;
                        }
                    });
                }

                const v = world.clone().project(cam3d);
                if (v.z < 1 && visible) {
                    lbl.style.display = 'block';
                    lbl.style.left = ((v.x*0.5+0.5)*W) + 'px';
                    lbl.style.top = ((-v.y*0.5+0.5)*H) + 'px';
                } else { lbl.style.display = 'none'; }
            });
            // Animate boats and fish (clouds are stationary)
            // Clouds: stationary, no animation needed

            // Boats: move back and forth toward terrain then rotate to go elsewhere
            boatsArr.forEach((b, bi) => {
                // Initialize movement state if needed
                if (b.userData.movePhase === undefined) {
                    b.userData.movePhase = 0; // 0 = toward terrain, 1 = away from terrain, 2 = rotating
                    b.userData.moveTimer = 0;
                    b.userData.moveMaxTime = 6 + Math.random() * 4; // longer time for slower movement
                    b.userData.currentDirection = Math.random() * Math.PI * 2; // initial heading
                    b.userData.targetDirection = b.userData.currentDirection;
                    b.userData.baseRadius = 25 + Math.random() * 15; // stay in mid-range
                }

                b.userData.moveTimer += dt;

                // Phase transitions
                if (b.userData.moveTimer > b.userData.moveMaxTime) {
                    b.userData.movePhase = (b.userData.movePhase + 1) % 3;
                    b.userData.moveTimer = 0;
                    
                    if (b.userData.movePhase === 0) {
                        // Moving toward terrain phase
                        b.userData.moveMaxTime = 6 + Math.random() * 4;
                    } else if (b.userData.movePhase === 1) {
                        // Moving away from terrain phase
                        b.userData.moveMaxTime = 6 + Math.random() * 4;
                    } else {
                        // Pick new direction to rotate toward
                        b.userData.targetDirection = Math.random() * Math.PI * 2;
                        b.userData.moveMaxTime = 3 + Math.random() * 2;
                    }
                }

                // Calculate radius based on direction and phase
                let radius = b.userData.baseRadius;
                if (b.userData.movePhase === 0) {
                    // Moving toward terrain: decrease radius
                    const progress = b.userData.moveTimer / b.userData.moveMaxTime;
                    radius = b.userData.baseRadius - progress * 10;
                } else if (b.userData.movePhase === 1) {
                    // Moving away from terrain: increase radius
                    const progress = b.userData.moveTimer / b.userData.moveMaxTime;
                    radius = (b.userData.baseRadius - 10) + progress * 10;
                } else {
                    // Rotation phase: gradually rotate direction
                    const progress = b.userData.moveTimer / b.userData.moveMaxTime;
                    const angleDiff = b.userData.targetDirection - b.userData.currentDirection;
                    // shortest path around circle
                    const shortestDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                    b.userData.currentDirection += shortestDiff * progress * 0.5;
                }

                // Position boat based on current phase direction and radius
                const nxpos = Math.cos(b.userData.currentDirection) * radius;
                const nzpos = Math.sin(b.userData.currentDirection) * radius;

                b.position.x = nxpos;
                b.position.z = nzpos;
                b.position.y = WATER_LEVEL + Math.sin(el * (0.6 + bi * 0.05)) * 0.06;

                // Face direction of travel
                const lookAhead = 0.02 + b.userData.speed * 0.5;
                const nextDir = b.userData.currentDirection + lookAhead;
                const lx = Math.cos(nextDir) * radius;
                const lz = Math.sin(nextDir) * radius;
                b.lookAt(new THREE.Vector3(lx, b.position.y, lz));
            });

            // Fish: swim under water along circular-ish paths
            fishArr.forEach((f, fi) => {
                f.userData.angle += f.userData.speed * (clock3d.getDelta());
                const ang = f.userData.angle;
                const r = f.userData.radius;
                f.position.x = Math.cos(ang) * r;
                f.position.z = Math.sin(ang) * r;
                // gentle vertical bob under the surface
                f.position.y = f.userData.depthBase + Math.sin(clock3d.getElapsedTime() * (0.8 + fi*0.02 + f.userData.speed*0.1)) * 0.12;
                // orient along velocity vector
                const vx = -Math.sin(ang) * f.userData.speed;
                const vz = Math.cos(ang) * f.userData.speed;
                const look = new THREE.Vector3(f.position.x + vx, f.position.y, f.position.z + vz);
                f.lookAt(look);
            });
            
            // Camera follow dog with orbit controls
            if (dogGrp) {
                const target = dogGrp.position.clone().add(camOffset);
                // Reduce vertical look offset so terrain and sea occupy more upper screen space
                target.y += 2.0; // previously 5.0
                
                // Calculate angle of dog relative to center (0,0) to keep camera "outside"
                // atan2(x, z) gives the angle from the Z axis.
                // We add PI/2 to align with how we want to view it (or just use as base)
                // Actually, standard math atan2(z, x).
                // Let's take Cartesian:
                // If dog is at (10, 0) -> Angle 0. Cam should be at (10+r, ...).
                // If dog is at (0, 10) -> Angle 90. Cam should be at (..., 10+r).
                // dogAngle = atan2(z, x).
                const dogAngle = Math.atan2(dogGrp.position.z, dogGrp.position.x);
                
                // The camCtrl.th is now an OFFSET from the dog's radial angle
                // We use (dogAngle + camCtrl.th) to orbit around the dog, 
                // but 0 offset means "radially outward"
                const totalAngle = dogAngle + camCtrl.th;
                
                const cx = camCtrl.r * Math.cos(totalAngle) * Math.sin(camCtrl.ph);
                const cz = camCtrl.r * Math.sin(totalAngle) * Math.sin(camCtrl.ph);
                const cy = camCtrl.r * Math.cos(camCtrl.ph);
                
                // Note: Spherical to Cartesian usually:
                // y = r * cos(phi) (if phi is from up/pole)
                // x = r * sin(phi) * cos(theta)
                // z = r * sin(phi) * sin(theta)
                // Using this standard mapping to be safe
                
                cam3d.position.copy(target).add(new THREE.Vector3(cx, cy, cz));
                cam3d.lookAt(target);
            }
            
            ren3d.render(scene3d, cam3d);
        }

        function getRankIdx() {
            let idx = rankData.length - 1;
            for (let r = rankData.length - 1; r >= 0; r--) {
                if (total >= rankData[r].threshold) { idx = r; break; }
            }
            return idx;
        }

        // === LOCATION FEATURES ===
        const locFeatures = {
            'Home Base': {
                desc: 'Where every adventure begins. Rest up and prepare!',
                unlockCoins: 0,
                activities: [
                    { name: 'Rest & Recover', desc: 'Take a break, recharge your energy.', reward: 10, type: 'quest' },
                    { name: 'Plan Your Day', desc: 'Set daily goals for bonus motivation.', reward: 15, type: 'quest' }
                ]
            },
            'Choco Hill': {
                desc: 'A sweet hilltop covered in cocoa dreams.',
                unlockCoins: 500,
                activities: [
                    { name: 'Chocolate Tasting', desc: 'Sample rare flavors from around the world.', reward: 25, type: 'quest' },
                    { name: 'Bake Brownies', desc: 'Whip up a batch of fudgy goodness.', reward: 40, type: 'quest' }
                ]
            },
            'Puppy Park': {
                desc: 'The happiest place on earth for good boys.',
                unlockCoins: 1500,
                activities: [
                    { name: 'Fetch Champion', desc: 'Play 20 rounds of fetch with Louis.', reward: 35, type: 'quest' },
                    { name: 'Dog Training', desc: 'Teach a new trick.', reward: 50, type: 'quest' }
                ]
            },
            'Bubble Tea': {
                desc: 'Refreshing drinks and chill vibes.',
                unlockCoins: 3000,
                activities: [
                    { name: 'Try a New Flavor', desc: 'Something adventurous today?', reward: 20, type: 'quest' },
                    { name: 'Boba Date', desc: 'Share a drink with a friend.', reward: 30, type: 'quest' }
                ]
            },
            'Shopping City': {
                desc: 'Retail therapy at its finest.',
                unlockCoins: 5000,
                activities: [
                    { name: 'Window Shopping', desc: 'Explore without spending (just coins!).', reward: 20, type: 'quest' },
                    { name: 'Find a Bargain', desc: 'Hunt for the best deal.', reward: 45, type: 'quest' }
                ]
            },
            'Sushi Palace': {
                desc: 'Fresh rolls and master chef vibes.',
                unlockCoins: 7000,
                activities: [
                    { name: 'Make Sushi', desc: 'Roll your own maki masterpiece.', reward: 55, type: 'quest' },
                    { name: 'Omakase Challenge', desc: 'Eat whatever the chef prepares!', reward: 40, type: 'quest' }
                ]
            },
            'Spa Island': {
                desc: 'Ultimate relaxation for mind & body.',
                unlockCoins: 10000,
                activities: [
                    { name: 'Face Mask Session', desc: 'Pamper yourself like royalty.', reward: 35, type: 'quest' },
                    { name: 'Meditation Hour', desc: '60 minutes of pure zen.', reward: 60, type: 'quest' }
                ]
            },
            'Bakery': {
                desc: 'Freshly baked pink cupcakes and sweet treats.',
                unlockCoins: 250,
                activities: [
                    { name: 'Decorate Cupcake', desc: 'Add sprinkles and cherries!', reward: 20, type: 'quest' },
                    { name: 'Eat Croissant', desc: 'Buttery goodness.', reward: 10, type: 'quest' }
                ]
            },
            'Koala Corner': {
                desc: 'A cozy tree for naps and cuddles.',
                unlockCoins: 1000,
                activities: [
                    { name: 'Hug a Tree', desc: 'Channel your inner koala.', reward: 30, type: 'quest' },
                    { name: 'Power Nap', desc: 'Sleep for 20 hours (or 20 mins).', reward: 50, type: 'quest' }
                ]
            },
            'Pink Boutique': {
                desc: 'Everything belongs to Bianca here.',
                unlockCoins: 4000,
                activities: [
                    { name: 'Buy Earrings', desc: 'Shiny things are best.', reward: 40, type: 'quest' },
                    { name: 'Lace Shopping', desc: 'Find the perfect fit.', reward: 45, type: 'quest' }
                ]
            },
            'Cozy Cinema': {
                desc: 'Movies under the stars with blankets.',
                unlockCoins: 6000,
                activities: [
                    { name: 'Watch RomCom', desc: 'Cry happy tears.', reward: 35, type: 'quest' },
                    { name: 'Popcorn Feast', desc: 'Sweet or salty? Both!', reward: 15, type: 'quest' }
                ]
            },
            'Greek Taverna': {
                desc: 'Opa! Delicious food and smashing plates.',
                unlockCoins: 8500,
                activities: [
                    { name: 'Sirtaki Dance', desc: 'Dance until you drop.', reward: 50, type: 'quest' },
                    { name: 'Plate Smashing', desc: 'Release some stress!', reward: 25, type: 'quest' }
                ]
            },
            'Beaver Lodge': {
                desc: 'Hard work pays off in this zodiac home.',
                unlockCoins: 11000,
                activities: [
                    { name: 'Build Dam', desc: 'Stack those logs.', reward: 60, type: 'quest' },
                    { name: 'Gnaw Wood', desc: 'Keep those teeth sharp.', reward: 20, type: 'quest' }
                ]
            },
            'Penguin Iceberg': {
                desc: 'Slide into fun on the ice.',
                unlockCoins: 12500,
                activities: [
                    { name: 'Belly Slide', desc: 'Wheeeee!', reward: 40, type: 'quest' },
                    { name: 'Catch Fish', desc: 'Yummy sashim- wait, raw fish.', reward: 50, type: 'quest' }
                ]
            },
            'Opera House': {
                desc: 'Where elegance meets adventure. The summit!',
                unlockCoins: 14000,
                activities: [
                    { name: 'Attend a Show', desc: 'Dress up and enjoy the performance.', reward: 70, type: 'quest' },
                    { name: 'Dance on Stage', desc: 'Your moment in the spotlight!', reward: 100, type: 'quest' }
                ]
            }
        };

        function showLocDetail(loc) {
            const feat = locFeatures[loc.name];
            if (!feat) return;
            const unlocked = coins >= feat.unlockCoins || total >= feat.unlockCoins;
            document.getElementById('loc-h-icon').innerText = loc.icon;
            document.getElementById('loc-h-name').innerText = loc.name;
            const status = document.getElementById('loc-h-status');
            if (unlocked) {
                status.className = 'loc-h-status unlocked';
                status.innerText = '\u2705 Unlocked \u2014 ' + feat.desc;
            } else {
                status.className = 'loc-h-status locked';
                status.innerText = '\uD83D\uDD12 Requires ' + feat.unlockCoins + ' coins \u2014 ' + feat.desc;
            }
            const acts = document.getElementById('loc-activities');
            acts.innerHTML = feat.activities.map((a, i) => `
                <div class="loc-act-card">
                    <div>
                        <div class="la-info">${a.name}</div>
                        <div class="la-desc">${a.desc}</div>
                        <div class="la-reward">+${a.reward} Coins</div>
                    </div>
                    <button class="loc-act-btn" ${!unlocked ? 'disabled' : ''} onclick="doLocActivity(${a.reward})">DO IT</button>
                </div>
            `).join('');
            document.getElementById('loc-overlay').classList.add('show');
        }

        function doLocActivity(reward) {
            coins += reward; total += reward;
            confetti({ particleCount: 40, spread: 50, origin: { y: 0.7 } });
            save(); render(); closeLoc();
        }

        function closeLoc() {
            document.getElementById('loc-overlay').classList.remove('show');
        }

        // === PROFILE SYSTEM ===
        const avatarChoices = ['\uD83D\uDC15','\uD83D\uDC31','\uD83E\uDD84','\uD83E\uDDA9','\uD83D\uDC27','\uD83D\uDC3C','\uD83E\uDDDA\u200D\u2640\uFE0F','\uD83E\uDE70','\uD83C\uDF1F','\uD83C\uDF38'];
        // Profile declared above
        
        function showProfile() {
            document.getElementById('pf-avatar-display').innerText = profile.avatar;
            document.getElementById('pf-name-display').innerText = profile.name;
            document.getElementById('pf-bio-display').innerText = profile.bio;
            document.getElementById('pf-coins').innerText = coins;
            document.getElementById('pf-total').innerText = total;
            document.getElementById('pf-vouchers').innerText = vouchers.filter(v => !v.redeemed).length;
            
            // Cloud Status
            let cloudStatus = document.getElementById('pf-cloud-status');
            if(!cloudStatus) {
                 cloudStatus = document.createElement('div');
                 cloudStatus.id = 'pf-cloud-status';
                 cloudStatus.style.marginTop = '10px';
                 cloudStatus.style.fontSize = '12px';
                 cloudStatus.style.color = '#8e8e93';
                 cloudStatus.innerText = '‚òÅÔ∏è Offline Mode';
                 document.querySelector('.profile-modal').appendChild(cloudStatus);
                 
                 // Add Force Save Button
                 const forceBtn = document.createElement('button');
                 forceBtn.innerText = "‚Üª Force Save";
                 forceBtn.style.cssText = "margin-top:5px; background:#e5e5ea; border:none; padding:5px 10px; border-radius:8px; font-size:11px; cursor:pointer;";
                 forceBtn.onclick = () => { save(); alert('Save triggered! Check status.'); };
                 document.querySelector('.profile-modal').appendChild(forceBtn);
            }
            if(window.isFirebaseReady && auth && auth.currentUser) {
                cloudStatus.innerText = '‚úÖ Cloud ID: ' + (auth.currentUser.email ? auth.currentUser.email.split('@')[0] : "User");
                cloudStatus.style.color = '#34c759';
                cloudStatus.style.fontWeight = 'bold';
            } else if (window.isFirebaseReady) {
                cloudStatus.innerHTML = '‚òÅÔ∏è <b>Offline Mode</b><br><span style="font-size:11px; opacity:0.8;">Restart app & enter a unique Profile Name to go online!</span>';
                cloudStatus.style.color = '#8e8e93';
            } else {
                cloudStatus.innerHTML = '‚ö†Ô∏è Cloud Not Configured';
            }

            // Rank progress
            const rIdx = getRankIdx();
            const nextRank = rIdx < rankData.length - 1 ? rankData[rIdx + 1] : null;
            const progress = nextRank ? Math.min(100, Math.round((total - rankData[rIdx].threshold) / (nextRank.threshold - rankData[rIdx].threshold) * 100)) : 100;
            const locsUnlocked = Object.values(locFeatures).filter(f => coins >= f.unlockCoins || total >= f.unlockCoins).length;
            document.getElementById('pf-extra-stats').innerHTML = `
                <div class="card" style="text-align:left; margin-top:12px;">
                    <div style="width:100%;">
                        <div style="font-weight:800;">${rankData[rIdx].icon} ${rankData[rIdx].name}</div>
                        <div style="font-size:11px; color:#8e8e93;">${nextRank ? 'Next: ' + nextRank.name + ' (' + nextRank.threshold + ' pts)' : 'MAX RANK! \uD83C\uDF89'}</div>
                        <div style="background:#e5e5ea; border-radius:6px; height:8px; margin-top:8px; overflow:hidden;">
                            <div style="background:var(--ios-pink); height:100%; width:${progress}%; border-radius:6px;"></div>
                        </div>
                    </div>
                </div>
                <div style="display:flex; gap:8px; margin-top:8px; font-size:12px; text-align:left;">
                    <div style="flex:1; background:#f2f2f7; border-radius:12px; padding:10px;">\uD83D\uDDFA\uFE0F <b>${locsUnlocked}/${Object.keys(locFeatures).length}</b> locations</div>
                    <div style="flex:1; background:#f2f2f7; border-radius:12px; padding:10px;">\uD83D\uDCCB <b>${customQuests.length + customRewards.length}</b> custom items</div>
                </div>
            `;
            document.getElementById('pf-name-input').value = profile.name;
            document.getElementById('pf-bio-input').value = profile.bio;
            const picker = document.getElementById('avatar-picker');
            picker.innerHTML = avatarChoices.map(a =>
                '<div class="avatar-opt ' + (a === profile.avatar ? 'selected' : '') + '" onclick="pickAvatar(\'' + a + '\')">' + a + '</div>'
            ).join('');
            document.getElementById('profile-overlay').classList.add('show');
        }

        function pickAvatar(a) {
            profile.avatar = a;
            document.querySelectorAll('.avatar-opt').forEach(el => el.classList.remove('selected'));
            event.target.closest('.avatar-opt').classList.add('selected');
            document.getElementById('pf-avatar-display').innerText = a;
        }

        /* Export/Import removed */

        function saveProfile() {
            const n = document.getElementById('pf-name-input').value.trim();
            const b = document.getElementById('pf-bio-input').value.trim();
            if (n) profile.name = n;
            profile.bio = b || '';
            
            save(); // Use unified optimistic save
            
            document.getElementById('pf-name-display').innerText = profile.name;
            document.getElementById('pf-bio-display').innerText = profile.bio;
            document.getElementById('pf-avatar-display').innerText = profile.avatar;
            document.getElementById('header-avatar').innerText = profile.avatar;
        }

        function closeProfile() {
            document.getElementById('profile-overlay').classList.remove('show');
        }

        function enterApp() {
            const val = document.getElementById('pass').value.trim();
            
            // LOCAL LOGIN
            if(val.toLowerCase() === 'louis') {
                startApp();
                return;
            }
            
            // CLOUD LOGIN ATTEMPT
            if (window.isFirebaseReady) {
                // If they enter something else, try to use it as a "Secret Code" login
                // We map this secret code to an email like "code@app.com"
                if (val.length > 3) {
                    const cleanVal = val.trim().toLowerCase(); // Always lowercase for consistency
                    const fakeEmail = cleanVal.replace(/\s/g, '') + "@questapp.local";
                    const fakePass = "secret_" + cleanVal.replace(/\s/g, ''); 
                    
                    // Try to login or create
                    auth.signInWithEmailAndPassword(fakeEmail, fakePass)
                        .then(() => {
                            // alert("Found your Cloud Save! Loading...");
                            startApp(true);
                        })
                        .catch(e => {
                            if(e.code === 'auth/user-not-found' || e.code === 'auth/invalid-credential' || e.code === 'auth/invalid-login-credentials') {
                                // Create new
                                if(confirm("New profile detected: '" + val + "'. Create new cloud save?")) {
                                    auth.createUserWithEmailAndPassword(fakeEmail, fakePass)
                                        .then(() => {
                                            // Force save immediately to seed the cloud with current local data
                                            // We need to ensure we set the profile name correctly first
                                            profile.name = val;
                                            save(); 
                                            alert("Cloud Profile Created! Sync active.");
                                            startApp(true);
                                        })
                                        .catch(err => alert("Creation Failed: " + err.message));
                                }
                            } else if (e.code === 'auth/operation-not-allowed' || e.code === 'auth/configuration-not-found') {
                                alert("FIREBASE CONFIG ERROR: Go to Firebase Console > Authentication > Sign-in method, and ENABLE 'Email/Password'.");
                            } else {
                                alert("Login Error: " + e.message);
                            }
                        });
                } else {
                    alert('Password too short for Cloud Profile.');
                }
            } else {
                alert('Password incorrect. (Cloud Sync not configured)');
            }
        }
        
        let isWaitingForSync = false;

        function startApp(isCloud = false) {
            document.getElementById('login').style.display = 'none';
            
            if(isCloud) {
                // Show blocking loader
                isWaitingForSync = true;
                const loader = document.createElement('div');
                loader.id = 'cloud-loader';
                loader.style.cssText = "position:fixed; inset:0; background:rgba(255,255,255,0.95); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; font-size:20px; font-weight:800; color:#333;";
                loader.innerHTML = '<div style="font-size:60px; margin-bottom:20px;">‚òÅÔ∏è</div><div>Downloading Data...</div><div style="font-size:14px; font-weight:normal; margin-top:10px; color:#666;">Do not close the page!</div>';
                document.body.appendChild(loader);
            }

            init3D();
            document.getElementById('header-avatar').innerText = profile.avatar;
            render();
            scheduleCat(true);
            
            // Start Cloud Sync if available
            if (db) {
                // Check if already signed in
                auth.onAuthStateChanged(u => {
                    if (u) {
                        console.log("Synced as " + u.uid);
                        setupSync(u.uid);
                    } else if (isCloud) {
                         // Wait a bit, sometimes auth propagates slowly
                         setTimeout(() => {
                             if(auth.currentUser) {
                                 setupSync(auth.currentUser.uid);
                             } else {
                                 console.error("Cloud mode requested but no user found?");
                                 if(document.getElementById('cloud-loader')) {
                                     document.getElementById('cloud-loader').innerHTML = '‚ö†Ô∏è Login Failed. Try again.';
                                     setTimeout(() => location.reload(), 2000);
                                 }
                             }
                         }, 2000);
                    }
                });
            }
        }

        function setupSync(uid) {
            userRef = db.collection('users').doc(uid);
            // Listen for changes with Metadata to distinguish Cache vs Server
            unsubscribe = userRef.onSnapshot({ includeMetadataChanges: true }, doc => {
                const isCache = doc.metadata.fromCache;
                console.log("Snapshot from:", isCache ? "Cache" : "Server");
                
                const loader = document.getElementById('cloud-loader');
                
                // 1. DATA PROCESSING (Always update UI with what we have)
                if (doc.exists) {
                    const d = doc.data();
                    
                    // TIMESTAMP SYNC LOGIC
                    // 1. Get Local Timestamp
                    const localTime = parseInt(localStorage.getItem('b_lastSaveTime') || '0');
                    
                    // 2. Get Cloud Timestamp
                    let cloudTime = d.lastSaveTime || 0;
                    if (!cloudTime && d.lastUpdated) {
                        cloudTime = d.lastUpdated.toMillis ? d.lastUpdated.toMillis() : 0;
                    }

                    // 3. Sync Decision Strategy
                    // We accept Cloud Data if:
                    // A. We are in the initial loading phase (isWaitingForSync)
                    // B. Cloud data is explicitly newer (cloudTime > localTime)
                    // C. Cloud has MORE progress (total > local total) - catch-up/merge logic
                    //    (This fixes the 'stuck on old data' issue if timestamps are messy)
                    
                    const cloudTotal = d.total || 0;
                    const isNewer = cloudTime > localTime;
                    const isMoreProgress = cloudTotal > total;
                    
                    // If it's a "Pending Write" (our own local save echoing back), ignore conflict checks to prevent loops
                    const isLocalEcho = doc.metadata.hasPendingWrites; 

                    let shouldSync = false;
                    
                    if (isWaitingForSync) shouldSync = true;
                    else if (isLocalEcho) shouldSync = false; // It's our own data, we already have it
                    else if (isNewer || isMoreProgress) shouldSync = true;

                    if (!shouldSync) {
                        console.log("Ignored Cloud Data: Local is newer or identical.", { cloudTime, localTime, cloudTotal, total });
                    } else {
                        console.log("Syncing Cloud Data...", { reason: isWaitingForSync ? "Init" : (isNewer ? "Newer" : "Progress"), cloudTotal, total });
                        
                        if(d.coins !== undefined) coins = d.coins;
                        if(d.total !== undefined) total = d.total;

                        try { if(d.vouchers) vouchers = JSON.parse(d.vouchers); } catch(e){}
                        
                        // Safe Parse for Custom Items
                        try { 
                            if(d.customQuests) {
                                const parsed = JSON.parse(d.customQuests);
                                if(Array.isArray(parsed)) customQuests = parsed;
                            }
                        } catch(e){}

                        try { 
                            if(d.customRewards) {
                                const parsed = JSON.parse(d.customRewards);
                                if(Array.isArray(parsed)) customRewards = parsed;
                            }
                        } catch(e){}
                        
                        if(d.profile) profile = d.profile;
                        
                        localStorage.setItem('b_coins', coins);
                        localStorage.setItem('b_total', total);
                        localStorage.setItem('b_profile', JSON.stringify(profile));
                        localStorage.setItem('b_custom_quests', JSON.stringify(customQuests));
                        localStorage.setItem('b_custom_rewards', JSON.stringify(customRewards));
                        localStorage.setItem('b_vouchers', JSON.stringify(vouchers));
                        
                        // Sync timestamps - Set local to cloud time to prevent bounce-back
                        localStorage.setItem('b_lastSaveTime', cloudTime || Date.now());
                        
                        render();
                        document.getElementById('header-avatar').innerText = profile.avatar;
                    }
                }

                // 2. LOCK LOGIC (Prevent overwrite until SERVER data arrives)
                if (loader) {
                    if (isCache) {
                        // We have cached data, but waiting for server confirmation
                        // Changing text so user knows we are checking
                        const txt = loader.querySelector('div:last-child');
                        if(txt) txt.innerText = "Verifying with Server...";
                        
                        // Fallback: If server doesn't respond in 5s, assume offline and unlock
                        if(!window.syncFallbackTimer) {
                            window.syncFallbackTimer = setTimeout(() => {
                                const l = document.getElementById('cloud-loader');
                                if(l) {
                                    l.remove();
                                    isWaitingForSync = false;
                                    console.warn("Server timed out, using cache.");
                                    const status = document.getElementById('pf-cloud-status');
                                    if(status) {
                                        status.innerText = '‚ö†Ô∏è Offline Mode (Cached)';
                                        status.style.color = '#ffcc00';
                                    }
                                }
                            }, 5000);
                        }
                    } else {
                        // Server Data Received! or Confirmed Non-Existence
                        if(window.syncFallbackTimer) clearTimeout(window.syncFallbackTimer);
                        
                        loader.innerHTML = '<div style="font-size:60px;">‚úÖ</div><div>Synced!</div>';
                        isWaitingForSync = false;
                        setTimeout(() => loader.remove(), 800);
                    }
                } else {
                    // Runtime update (background) - ensure lock is off
                    isWaitingForSync = false; 
                }
                
                // Update Badge
                let cloudStatus = document.getElementById('pf-cloud-status');
                if(cloudStatus && !isCache && doc.exists) {
                    cloudStatus.innerText = '‚úÖ Synced: ' + (auth.currentUser.email ? auth.currentUser.email.split('@')[0] : "Profile");
                    cloudStatus.style.color = '#34c759';
                }

                if (!doc.exists && !isCache) {
                    // Server confirms no data exists -> First Save
                    save(); 
                }
            }, err => {
                console.error("Sync failed", err);
                isWaitingForSync = false;
                if(document.getElementById('cloud-loader')) document.getElementById('cloud-loader').remove();
            });
        }
        
        // linkCloud function removed as it is no longer used

        function render() {
            document.getElementById('coin-txt').innerText = "üí∞ " + coins.toString().padStart(4, '0');
            
            // Rank Logic
            let idx = getRankIdx();
            document.getElementById('rank-name').innerText = rankData[idx].name;

            // Update Locations Menu (Locks)
            updateLocMenu();

            // Update 3D dog position along path
            updateDog3D(Math.min(coins / 15000, 1));

            // Voucher badge
            const openCount = vouchers.filter(v => !v.redeemed).length;
            const badge = document.getElementById('voucher-badge');
            if (openCount > 0) { badge.style.display = 'block'; badge.innerText = openCount; }
            else { badge.style.display = 'none'; }

            // List Render
            const list = document.getElementById('main-list');
            const allQuests = quests.concat(customQuests);
            const allShop = shop.concat(customRewards);
            const items = (tab === 'q') ? allQuests : allShop;
            const baseLen = (tab === 'q') ? quests.length : shop.length;

            list.innerHTML = items.map((i, idx) => {
                const isCustom = idx >= baseLen;
                const customIdx = idx - baseLen;
                return `
                <div class="card" style="${tab==='s' && coins < i.p ? 'opacity:0.6' : ''}; position:relative;">
                    ${isCustom ? `<div onclick="deleteItem('${tab}', ${customIdx})" style="position:absolute; top:8px; right:8px; width:20px; height:20px; text-align:center; line-height:20px; font-size:14px; color:#ff3b30; cursor:pointer; background:rgba(0,0,0,0.05); border-radius:50%; z-index:10;">‚úï</div>` : ''}
                    <div>
                        <div style="font-weight:800; padding-right:24px;">${i.t}</div>
                        <div style="font-size:12px; color:#8e8e93;">${i.d || ''}</div>
                        <div style="color:${tab==='q' ? '#ff9500' : 'var(--ios-pink)'}; font-weight:800; margin-top:5px;">
                            ${tab==='q' ? '+'+i.r+' Coins' : 'Price: '+i.p}
                        </div>
                    </div>
                    <button class="btn-ios" ${tab==='s' && coins < i.p ? 'disabled' : ''} onclick="${tab==='q' ? 'doQuest('+i.r+')' : 'doBuy(\''+i.t.replace(/'/g,"\\\\'")+'\','+i.p+')'}">
                        ${tab==='q' ? 'DONE' : 'BUY'}
                    </button>
                </div>
            `}).join('');
            list.innerHTML += '<button class="add-quest-btn" onclick="' + (tab==='q' ? 'showAddQuest()' : 'showAddReward()') + '">+ Add ' + (tab==='q' ? 'Quest' : 'Reward') + '</button>';

            // Update location label lock/unlock styling
            locLabels3d.forEach(({ el: lbl, loc }) => {
                if (!loc) return;
                const feat = locFeatures[loc.name];
                const tag = lbl.querySelector('.loc-tag-3d');
                if (feat && tag) {
                    const unl = coins >= feat.unlockCoins || total >= feat.unlockCoins;
                    tag.classList.toggle('unlocked', unl);
                    tag.classList.toggle('locked', !unl);
                }
            });
        }

        function setTab(t) {
            tab = t;
            document.getElementById('tab-q').className = t==='q' ? 'tab active' : 'tab';
            document.getElementById('tab-s').className = t==='s' ? 'tab active' : 'tab';
            render();
        }

        function deleteItem(type, idx) {
            if(confirm('Delete this custom item?')) {
                if (type === 'q') customQuests.splice(idx, 1);
                else customRewards.splice(idx, 1);
                save();
                render();
            }
        }

        function doQuest(amt) {
            coins += amt; total += amt;
            confetti({ particleCount: 50, spread: 60, origin: { y: 0.6 } });
            save(); render();
        }

        function doBuy(t, p) {
            coins -= p;
            vouchers.push({ title: t, date: new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' }) });
            confetti({ particleCount: 150, spread: 80, colors: ['#ff2d55'] });
            save(); render();
            setTimeout(() => showVouchers(), 600);
        }

        function showVouchers() {
            const el = document.getElementById('voucher-list');
            if (vouchers.length === 0) {
                el.innerHTML = '<div class="voucher-empty">No vouchers yet!<br>Buy rewards to collect them here üéÄ</div>';
            } else {
                el.innerHTML = vouchers.map((v, i) => `
                    <div class="voucher-card ${v.redeemed ? 'redeemed' : ''}">
                        <span class="v-stamp">${v.redeemed ? '\u2705' : '\ud83c\udf9f\ufe0f'}</span>
                        <div class="v-title">${v.title}</div>
                        <div class="v-date">${v.redeemed ? 'Used ' + v.redeemedDate : 'Claimed ' + v.date}</div>
                        ${v.redeemed
                            ? '<span class="v-status used">REDEEMED</span>'
                            : '<span class="v-status open" onclick="redeemVoucher(' + i + ')">\u2728 REDEEM</span>'
                        }
                    </div>
                `).join('');
            }
            document.getElementById('voucher-overlay').classList.add('show');
        }

        function redeemVoucher(idx) {
            vouchers[idx].redeemed = true;
            vouchers[idx].redeemedDate = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
            save();
            showVouchers();
        }

        function closeVouchers() {
            document.getElementById('voucher-overlay').classList.remove('show');
        }

        const rankData = [
            { name: "BABY DUCKLING", icon: "üê•", threshold: 0 },
            { name: "BRONZE KOALA", icon: "üê®", threshold: 500 },
            { name: "SILVER PENGUIN", icon: "üêß", threshold: 1200 },
            { name: "GOLDEN BEAVER", icon: "ü¶´", threshold: 2000 },
            { name: "SAPPHIRE DOLPHIN", icon: "üê¨", threshold: 3500 },
            { name: "RUBY FLAMINGO", icon: "ü¶©", threshold: 5000 },
            { name: "DIAMOND UNICORN", icon: "ü¶Ñ", threshold: 7500 },
            { name: "PLATINUM PHOENIX", icon: "üî•", threshold: 10000 },
            { name: "GRAND BALLERINA", icon: "ü©∞", threshold: 15000 }
        ];

        function showRanks() {
            let idx = getRankIdx();
            const html = rankData.map((r, i) => `
                <div class="rank-row ${i === idx ? 'current' : ''}">
                    <span class="rank-icon">${r.icon}</span>
                    ${r.name}
                    <span class="rank-threshold">${r.threshold}+ pts</span>
                </div>
            `).join('');
            document.getElementById('rank-list').innerHTML = html;
            document.getElementById('rank-overlay').classList.add('show');
        }

        function closeRanks() {
            document.getElementById('rank-overlay').classList.remove('show');
        }

        function save() {
            // Safety: Do not save if we are still waiting for initial cloud sync
            // This prevents overwriting the cloud with empty local data on login
            if(isWaitingForSync) {
                console.warn("Save blocked: Still syncing...");
                return;
            }

            const timestamp = Date.now();
            localStorage.setItem('b_lastSaveTime', timestamp);

            localStorage.setItem('b_coins', coins);
            localStorage.setItem('b_total', total);
            localStorage.setItem('b_vouchers', JSON.stringify(vouchers));
            localStorage.setItem('b_custom_quests', JSON.stringify(customQuests));
            localStorage.setItem('b_custom_rewards', JSON.stringify(customRewards));
            
            // OPTIMISTIC UI: Show success immediately (since local save is done)
            showSaveIndicator('‚úÖ Saved');
            setTimeout(() => showSaveIndicator(''), 2000);
            
            // Cloud Push (Background)
            if (db && auth.currentUser) {
                const statusEl = document.getElementById('pf-cloud-status');
                if(statusEl) statusEl.innerText = '‚òÅÔ∏è Syncing...';

                db.collection('users').doc(auth.currentUser.uid).set({
                    coins: coins,
                    total: total,
                    vouchers: JSON.stringify(vouchers),
                    customQuests: JSON.stringify(customQuests),
                    customRewards: JSON.stringify(customRewards),
                    profile: profile,
                    lastSaveTime: timestamp, // Sync timestamp to handle conflicts
                    serverTimestamp: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true })
                .then(() => {
                    console.log("Cloud Background Sync Success");
                    if(statusEl) {
                        statusEl.innerText = '‚úÖ Cloud Synced';
                        statusEl.style.color = '#34c759';
                    }
                })
                .catch(err => {
                    console.error("Cloud Background Sync Error", err);
                    if(statusEl) {
                        statusEl.innerText = '‚ö†Ô∏è Sync Pending';
                        statusEl.style.color = 'orange';
                    }
                    // We do NOT alert user, to avoid interrupting flow. 
                    // Local save is secure, cloud will catch up later.
                });
            }
        }

        function showSaveIndicator(msg) {
            let el = document.getElementById('save-toast');
            if(!el) {
                el = document.createElement('div');
                el.id = 'save-toast';
                el.style.cssText = "position:fixed; top:10px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.7); color:white; padding:5px 15px; border-radius:20px; font-size:12px; z-index:10000; pointer-events:none; transition:opacity 0.3s;";
                document.body.appendChild(el);
            }
            if(!msg) {
                el.style.opacity = '0';
            } else {
                el.innerText = msg;
                el.style.opacity = '1';
            }
        }

        function showAddQuest() {
            document.getElementById('addq-name').value = '';
            document.getElementById('addq-desc').value = '';
            document.getElementById('addq-pts').value = '';
            document.getElementById('addq-overlay').classList.add('show');
        }

        function closeAddQuest() {
            document.getElementById('addq-overlay').classList.remove('show');
        }

        function saveNewQuest() {
            const name = document.getElementById('addq-name').value.trim();
            const desc = document.getElementById('addq-desc').value.trim();
            const pts = parseInt(document.getElementById('addq-pts').value);
            if (!name || !pts || pts < 5) return;
            customQuests.push({ t: name, d: desc, r: pts });
            save();
            closeAddQuest();
            render();
        }

        function showAddReward() {
            document.getElementById('addr-name').value = '';
            document.getElementById('addr-desc').value = '';
            document.getElementById('addr-price').value = '';
            document.getElementById('addr-overlay').classList.add('show');
        }

        function closeAddReward() {
            document.getElementById('addr-overlay').classList.remove('show');
        }

        function saveNewReward() {
            const name = document.getElementById('addr-name').value.trim();
            const desc = document.getElementById('addr-desc').value.trim();
            const price = parseInt(document.getElementById('addr-price').value);
            if (!name || !price || price < 10) return;
            customRewards.push({ t: name, d: desc, p: price });
            save();
            closeAddReward();
            render();
        }

        // === BLACK CAT ===
        let currentCatQ = null;

        function showReset() {
            document.getElementById('reset-overlay').classList.add('show');
        }
        function closeReset() {
            document.getElementById('reset-overlay').classList.remove('show');
        }
        function confirmReset() {
            coins = 0; total = 0;
            vouchers = []; customQuests = []; customRewards = [];
            profile = { name: 'Adventurer', bio: 'On a quest for greatness!', avatar: '\uD83D\uDC15' };
            
            save(); // Triggers optimistic save & cloud sync
            
            closeReset();
            render();
        }

        function scheduleCat(firstTime) {
            // First time: 10-20s, after that: 45s to 3 min
            const delay = firstTime ? (10 + Math.random() * 10) * 1000 : (45 + Math.random() * 135) * 1000;
            catTimer = setTimeout(() => {
                summonCat();
            }, delay);
        }

        function summonCat() {
            currentCatQ = catQuestions[Math.floor(Math.random() * catQuestions.length)];
            document.getElementById('cat-question').innerText = currentCatQ.q;
            document.getElementById('cat-btns').style.display = 'flex';
            document.getElementById('cat-result').innerHTML = '';
            document.getElementById('cat-modal').classList.remove('leaving');
            document.getElementById('cat-overlay').classList.remove('penalty');
            document.getElementById('cat-overlay').classList.add('show');
        }

        function catAnswer(yes) {
            document.getElementById('cat-btns').style.display = 'none';
            const result = document.getElementById('cat-result');
            if (yes) {
                result.innerHTML = '<div class="cat-safe-txt">Good human! You\'re safe... for now. üòº</div>';
            } else {
                const pen = currentCatQ.penalty;
                coins = Math.max(0, coins - pen);
                total = Math.max(0, total - Math.floor(pen / 2));
                save(); render();
                document.getElementById('cat-overlay').classList.add('penalty');
                result.innerHTML = '<div class="cat-penalty-txt">‚ò†Ô∏è -' + pen + ' Coins!</div>';
            }
            setTimeout(() => {
                document.getElementById('cat-modal').classList.add('leaving');
                setTimeout(() => {
                    document.getElementById('cat-overlay').classList.remove('show');
                    document.getElementById('cat-overlay').classList.remove('penalty');
                    scheduleCat(false);
                }, 400);
            }, 1800);
        }
    </script>
</body>
</html>